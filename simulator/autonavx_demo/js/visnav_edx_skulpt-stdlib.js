Sk.builtinFiles={"files": {"src/lib/simulator/simulator.py": "import sys\nimport math\nimport numpy as np  # for cross, inv, random, arange\n#from simulator.navdata import Navdata\n\nif(sys.platform != \"skulpt\"):\n    import matplotlib.pyplot as plt\n    from pylab import *\n    from mpl_toolkits.mplot3d import Axes3D\n    import time\n\nclass Simulator():\n\n    start_time = 0  # in secs\n    end_time   = 1\n    dt         = 0.005\n\n\n    def __init__(self, drone, controller):\n        self.drone         = drone\n        self.controller    = controller\n        self.step_count    = 0\n        if(sys.platform != \"skulpt\"):\n            self.x         = []\n            self.y         = []\n            self.z         = []\n            self.roll      = []\n            self.pitch     = []\n            self.yaw       = []\n            self.cmd1      = []\n            self.cmd2      = []\n            self.cmd3      = []\n            self.cmd4      = []\n            self.e_yaw     = []\n            self.e_x       = []\n            self.e_y       = []\n            self.e_z       = []\n            self.roll_des  = []\n            self.pitch_des = []\n            self.yaw_des   = []\n\n\n    def reset(self):\n        # TODO: reset all states\n        self.theta_desired    = np.array([[0.0], [0.0], [0.0]])\n        self.thetadot_desired = np.array([[0.0], [0.0], [0.0]])\n        self.x_desired        = np.array([[0.0], [0.0], [0.0]])\n        self.xdot_desired     = np.array([[0.0], [0.0], [0.0]])\n        self.drone.x          = np.array([[0.0],[0.0],[0.0]])\n        self.drone.xdot       = np.array([[0.0],[0.0],[0.0]])\n        self.drone.xdoubledot = np.array([[0.0],[0.0],[0.0]])\n        self.drone.theta      = np.array([[0.0],[0.0],[0.0]])\n        self.drone.omega      = np.array([[0.0],[0.0],[0.0]])\n        self.drone.thetadot   = np.array([[0.0],[0.0],[0.0]])\n\n    def get_drone_pose(self):\n        return [self.drone.x.item(0), self.drone.x.item(1), self.drone.x.item(2), self.drone.theta.item(0), self.drone.theta.item(1), self.drone.theta.item(2)];\n\n    def get_drone_navdata(self):\n        import simulator.navdata\n        navdata=simulator.navdata.Navdata()\n\n        local_velocity = np.dot(self.drone.yaw_rotation().transpose(), self.drone.xdot);\n\n        navdata.vx   = local_velocity.item(0)\n        navdata.vy   = local_velocity.item(1)\n        navdata.vz   = local_velocity.item(2)\n        navdata.ax   = self.drone.xdoubledot.item(0)\n        navdata.ay   = self.drone.xdoubledot.item(1)\n        navdata.az   = self.drone.xdoubledot.item(2)\n        navdata.altd = self.drone.x.item(2)\n        navdata.rotX = self.drone.theta.item(0)\n        navdata.rotY = self.drone.theta.item(1)\n        navdata.rotZ = self.drone.theta.item(2)\n        return navdata;\n\n    def set_input(self, sim_input):\n        #self.theta_desired[0]   = sim_input[0];\n        #self.theta_desired[1]   = sim_input[1];\n        #self.theta_desired[2]   = sim_input[2];\n        #self.xdot_desired[2]    = sim_input[3];\n        self.xdot_desired[0]     = sim_input[0];\n        self.xdot_desired[1]     = sim_input[1];\n        self.thetadot_desired[2] = sim_input[2];\n        self.xdot_desired[2]     = sim_input[3];\n        self.xdot_desired        = np.dot(self.drone.yaw_rotation(), self.xdot_desired)\n\n    def set_input_world(self, lin_vel, yaw_vel):\n        self.xdot_desired[0]     = lin_vel[0]\n        self.xdot_desired[1]     = lin_vel[1]\n        self.xdot_desired[2]     = lin_vel[2]\n        self.thetadot_desired[2] = yaw_vel;\n\n    def simulate_step(self, t, dt):\n        self.step_count += 1\n\n        #if(int(t / 8.0) % 2 == 0):\n        #    self.xdot_desired[0] = 0.75;\n        #    self.xdot_desired[1] = 0.1;\n        #else:\n        #    self.xdot_desired[0] = -0.75;\n        #    self.xdot_desired[1] = -0.1;\n        #self.xdot_desired = np.dot(self.drone.yaw_rotation(), self.xdot_desired)\n\n\n        #inputCurrents = self.controller.calculate_control_command(dt, self.theta_desired, self.thetadot_desired,self.x_desired,self.xdot_desired)\n        inputCurrents, acc = self.controller.calculate_control_command3(dt, self.xdot_desired, self.thetadot_desired.item(2))\n        omega = self.drone.omega;#thetadot_in_body()  # calculate current angular velocity in body frame\n\n        #torques_thrust      = self.drone.torques_thrust(np.array([inputCurrents]).transpose())\n        torques_thrust       = self.drone.torques_thrust(inputCurrents)\n        #print acc.transpose();\n        # print omega.transpose()\n        linear_acceleration  = self.linear_acceleration(torques_thrust[3], self.drone.theta, self.drone.xdot)  # calculate the resulting linear acceleration\n        omegadot             = self.angular_acceleration(torques_thrust[0:3,0], omega)  # calculate resulting angular acceleration\n        #print \"angular acc\", omegadot.transpose()\n        #linear_acceleration = self.linear_acceleration2(inputCurrents, self.drone.theta, self.drone.xdot)  # calculate the resulting linear acceleration\n        #omegadot            = self.angular_acceleration2(inputCurrents, omega)  # calculate resulting angular acceleration\n\n        omega = omega + dt * omegadot  # integrate up new angular velocity in the body frame\n\n        #print \"inputs:\", inputCurrents\n        #print \"omega:\", omega.transpose(), \"omegadot:\", omegadot.transpose()\n        self.drone.omega    = omega;\n        self.drone.thetadot = np.dot(self.drone.angle_rotation_to_world().transpose(), omega)  # calculate roll, pitch, yaw velocities\n        self.drone.theta    = self.drone.theta + dt * self.drone.thetadot  # calculate new roll, pitch, yaw angles\n\n        #print self.drone.xdot.transpose(), self.drone.theta.transpose(), omega.transpose(), omegadot.transpose()\n        #print \"d\", inputCurrents\n        #print \"a\", torques_thrust[0:3,0], \"b\", omega, \"c\", omegadot\n\n        #print \"thetadot:\",self.drone.thetadot\n        #print(\"New theta\",self.drone.theta)\n        self.drone.xdoubledot = linear_acceleration\n        self.drone.xdot       = self.drone.xdot + dt * linear_acceleration  # calculate new linear drone speed\n        self.drone.x          = self.drone.x + dt * self.drone.xdot  # calculate new drone position\n        #print \"acc\", linear_acceleration\n        #print \"theta\", self.drone.theta\n        #print(\"Position\",self.drone.x.transpose())\n\n        if(sys.platform == \"skulpt\"):\n            import plot\n            plot.plot_pose(\"ardrone\", self.drone.x, self.drone.theta)\n            plot.plot_trajectory(\"ardrone\", self.drone.x)\n            plot.plot_motor_command(\"ardrone\", inputCurrents)\n\n\n        elif(self.step_count % 50 == 0): #save trajectory for plotting\n            vel  = np.dot(self.rotation(self.drone.theta).transpose(), self.drone.xdot)\n            vel  = self.drone.xdot\n            #vel = self.drone.x\n            #vel = acc\n            #vel = self.drone.thetadot_in_body();\n            #vel = self.drone.xdot;\n\n            self.x.append(vel.item(0))\n            self.y.append(vel.item(1))\n            self.z.append(vel.item(2))\n\n            ang = self.drone.theta\n\n            self.roll.append( ang.item(0))\n            self.pitch.append(ang.item(1))\n            self.yaw.append(  ang.item(2))\n            #print self.theta_desired.item(2)\n            self.cmd1.append(inputCurrents[0] - inputCurrents[2])\n            self.cmd2.append(inputCurrents[1] - inputCurrents[3])\n            self.cmd3.append(inputCurrents[0] - inputCurrents[1])\n            self.cmd4.append(inputCurrents[3])\n            self.roll_des.append(self.theta_desired[0])\n            self.pitch_des.append(self.theta_desired[1])\n            self.yaw_des.append(self.theta_desired[2])\n\n\n\n    def simulate(self, duration):\n        self.end_time = duration\n        self.reset()\n\n        # Step through the simulation, updating the drone state.\n        t    = self.start_time\n        fig1 = figure(1)\n        fig2 = figure(2)\n        fig3 = figure(3)\n        fig4 = figure(4)\n\n\n        while t <= self.end_time:\n            self.simulate_step(t, self.dt)\n            t += self.dt\n\n            # only plot every\n            frac = 5.0 * t + self.dt * 0.1;\n\n            if((frac - int(frac)) < (self.dt * 0.5) and sys.platform != \"skulpt\"):\n                #ion()\n                ###########################################\n                plt.figure(1)\n                fig1.suptitle('Position x,y,z')\n                #ax  = fig1.add_subplot(111, projection='3d')\n                #ax.plot(self.x, self.y, self.z)\n                #ax.axis([-5, 5, -5, 5])\n                #ax.set_zlim3d( -5, 5 )\n                #ax.set_xlabel('x')\n                #ax.set_ylabel('y')\n                #ax.set_zlabel('z')\n                #plt.ylim(-1.5,+1.5)\n                #plt.xlim(-1.5,+1.5)\n                ax_x = fig1.add_subplot(311)\n                ax_y = fig1.add_subplot(312)\n                ax_z = fig1.add_subplot(313)\n                #ax_z.ylim(-2.0, 2)\n                ax_x.plot(self.x)\n                ax_y.plot(self.y)\n                ax_z.plot(self.z)\n                draw()\n                fig1.show()\n\n                ###########################################\n                plt.figure(2)\n                fig2.suptitle('Position roll, pitch, yaw')\n                ax_roll  = fig2.add_subplot(311)\n                ax_roll.plot(self.roll)\n                ax_roll.plot(self.roll_des)\n                #ax_roll.legend(\"des\",\"act\",right)\n                ax_pitch = fig2.add_subplot(312, sharey=ax_roll)\n                ax_pitch.plot(self.pitch)\n                ax_pitch.plot(self.pitch_des)\n\n                ax_yaw = fig2.add_subplot(313, sharey=ax_roll)\n                ax_yaw.plot(self.yaw)\n                ax_yaw.plot(self.yaw_des)\n                draw()\n                fig2.show()\n\n                ###########################################\n                #plt.figure(3)\n                #plt.ylim(-5,+5)\n                #fig3.suptitle('Errors x,y,z,yaw ')\n                #ax_x   = fig3.add_subplot(411)\n                #ax_x.plot(self.e_x)\n                #ax_y   = fig3.add_subplot(412, sharey=ax_x)\n                #ax_y.plot(self.e_y)\n                #ax_z   = fig3.add_subplot(413, sharey=ax_x)\n                #ax_z.plot(self.e_z)\n                #ax_yaw = fig3.add_subplot(414, sharey=ax_x)\n                #ax_yaw.plot(self.e_yaw)\n                #draw()\n                #fig3.show()\n                ############################################\n                plt.figure(4)\n                #plt.ylim(-2,2)\n                fig4.suptitle('Control Commands')\n                ax_1    = fig4.add_subplot(411)\n                ax_1.plot(self.cmd1)\n                ax_2    = fig4.add_subplot(412,sharey=ax_1)\n                ax_2.plot(self.cmd2)\n                ax_3    = fig4.add_subplot(413,sharey=ax_1)\n                ax_3.plot(self.cmd3)\n                #ax_4   = fig4.add_subplot(414,sharey=ax_1)\n                #ax_4.plot(self.cmd4)\n                fig4.show()\n                #pause(0.1)\n\n    def deg2rad(self,degrees):\n        return np.array(map(math.radians, degrees))\n\n    def rotation(self, angles):  # translate angles to intertial/world frame\n        phi   = angles.item(0)\n        theta = angles.item(1)\n        psi   = angles.item(2)\n\n        c_phi   = math.cos(phi);\n        s_phi   = math.sin(phi);\n        c_theta = math.cos(theta);\n        s_theta = math.sin(theta);\n        c_psi   = math.cos(psi)\n        s_psi   = math.sin(psi)\n\n        #ZYZ Euler nach Paper\n        #R = np.array([[c_phi * c_psi - c_theta * s_phi * s_psi, -c_psi * s_phi - c_phi * c_theta * s_psi, s_theta * s_psi],\n        #              [c_theta * c_psi * s_phi + c_phi * s_psi, c_phi * c_theta * c_psi - s_phi * s_psi,  -c_psi * s_theta],\n        #              [s_phi * s_theta, c_phi * s_theta, c_theta]])\n        # Master thesis XYZ\n        R = np.array([[c_psi * c_theta, c_psi * s_theta * s_phi - s_psi * c_phi, c_psi * s_theta * c_phi + s_psi * s_phi],\n                      [s_psi * c_theta, s_psi * s_theta * s_phi + c_psi * c_phi, s_psi * s_theta * c_phi - c_psi * s_phi],\n                      [-s_theta, c_theta * s_phi, c_theta * c_phi]])\n\n        #ZYZ Euler nach craig\n        #R = np.array([[math.cos(psi)*math.cos(theta)*math.cos(phi)-math.sin(psi)*math.sin(phi), -math.cos(psi)*math.cos(theta)*math.sin(phi)-math.sin(psi)*math.cos(phi), math.cos(psi)*math.sin(theta) ],\n        #              [math.sin(psi)*math.cos(theta)*math.cos(phi)+math.cos(psi)*math.sin(phi), -math.sin(psi)*math.cos(theta)*math.sin(phi)+math.cos(psi)*math.cos(phi), math.sin(psi)*math.sin(theta) ],\n        #              [-math.sin(theta)*math.cos(phi), math.sin(theta)*math.sin(phi), math.cos(theta)]])\n\n        return R\n\n    def linear_acceleration(self, thrust, angles, xdot):\n        gravity = np.array([[0], [0], [-self.drone.g]])\n        R = self.rotation(angles)\n\n        T      = np.dot(R, np.array([[0], [0], [thrust]]))\n        F_drag = -self.drone.kd * xdot\n        a      = gravity + (T + F_drag) / self.drone.m\n        return a\n\n    def angular_acceleration(self, torques, omega):\n        # this transpose stuff really sucks\n        omegaddot = np.dot(self.drone.I_inv, (torques.transpose() - np.cross(omega.transpose(), np.dot(self.drone.I, omega).transpose())).transpose());\n        return omegaddot\n", "src/lib/time/__init__.js": "\n/*\n\tBarebones implementation of the Python time package.\n\n\tFor now, only the time() function is implemented.\n*/\n \nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    mod.time = new Sk.builtin.func(function() {\n\t  return Sk.builtin.assk$(new Date().getTime() / 1000, undefined);\n    });\n\n    return mod;\n}\n", "src/lib/operator/__init__.js": "/*\n *  __author__: Isaac Dontje Lindell (i@isaacdontjelindell.com)\n *\n *  Implementation of the Python operator module.\n */\n\nvar $builtinmodule = function(name) {\n    var mod = {};\n\n    mod.lt = new Sk.builtin.func(function(a, b) { return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'Lt')); });\n    mod.__lt__ = mod.lt;\n\n    mod.le = new Sk.builtin.func(function(a, b) { return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'LtE')); });\n    mod.__le__ = mod.le;\n\n    mod.eq = new Sk.builtin.func(function(a, b) { return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'Eq')); });\n    mod.__eq__ = mod.eq;\n\n    mod.ne = new Sk.builtin.func(function(a, b) { return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'NotEq')); });\n    mod.__ne__ = mod.ne;\n\n    mod.ge = new Sk.builtin.func(function(a, b) { return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'GtE')); });\n    mod.__ge__ = mod.ge;\n\n    mod.gt = new Sk.builtin.func(function(a, b) { return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'Gt')); });\n    mod.__gt__ = mod.gt;\n\n    mod.not_ = new Sk.builtin.func(function (obj) { throw new Sk.builtin.NotImplementedError(\"operator.not_() is not yet implemented in Skulpt\"); });\n\n    mod.truth = new Sk.builtin.func(function(obj) { return Sk.builtin.bool(obj); });\n\n    mod.is_ = new Sk.builtin.func(function(a, b) { return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'Is')); });\n\n    mod.is_not = new Sk.builtin.func(function(a, b) { return Sk.builtin.bool(Sk.misceval.richCompareBool(a, b, 'IsNot')); });\n\n    mod.abs = new Sk.builtin.func(function(obj) { return Sk.misceval.callsim(Sk.builtin.abs, obj); });\n    mod.__abs__ = mod.abs;\n\n    // The documentation says that operator.add() is defined for a and b numbers, but\n    // CPython (2.6) allows a and b to be other types (e.g. str)\n    mod.add = new Sk.builtin.func(function (a, b) { return Sk.abstr.objectAdd(a, b); });\n    mod.__add__ = mod.add;\n\n    mod.and_ = new Sk.builtin.func(function (a, b) { return Sk.builtin.nmber.prototype['nb$and'].call(a, b); });\n    mod.__and__ = mod.and_;\n\n    mod.div = new Sk.builtin.func(function (a, b) { return Sk.builtin.nmber.prototype['nb$divide'].call(a, b); });\n    mod.__div__ = mod.div;\n\n    mod.floordiv = new Sk.builtin.func(function (a, b) { return Sk.builtin.nmber.prototype['nb$floor_divide'].call(a, b); });\n    mod.__floordiv__ = mod.floordiv;\n\n    // Doesn't look like anything has the __index__ magic function anyway\n    mod.index = new Sk.builtin.func(function (a) { throw new Sk.builtin.NotImplementedError(\"operator.index() is not yet implemented in Skulpt\"); });\n    mod.__index__ = mod.index;\n\n    // Note: Sk.abstr.numberUnaryOp(obj, 'Invert') looks for the function nb$invert() on obj.\n    // However, it doesn't look like that function has been implemented for any existing object types.\n    // I've gone ahead and created this function for completeness' sake, but expect any use of it to\n    // result in an error.\n    mod.inv = new Sk.builtin.func(function (obj) { return Sk.abstr.numberUnaryOp(obj, 'Invert'); });\n    mod.__inv__ = mod.inv;\n    mod.invert = mod.inv;\n    mod.__invert__ = mod.inv;\n\n    mod.lshift = new Sk.builtin.func(function (a, b) { return Sk.builtin.nmber.prototype['nb$lshift'].call(a, b); });\n    mod.__lshift__ = mod.lshift;\n\n    mod.mod = new Sk.builtin.func(function (a, b) { return Sk.builtin.nmber.prototype['nb$remainder'].call(a, b); });\n    mod.__mod__ = mod.mod;\n\n    mod.mul = new Sk.builtin.func(function (a, b) { return Sk.builtin.nmber.prototype['nb$multiply'].call(a, b); });\n    mod.__mul__ = mod.mul;\n\n    mod.neg = new Sk.builtin.func(function (obj) { return Sk.abstr.objectNegative(obj); });\n    mod.__neg__ = mod.neg;\n\n    mod.or_ = new Sk.builtin.func(function (a, b) { return Sk.builtin.nmber.prototype['nb$or'].call(a, b); });\n    mod.__or__ = mod.or_;\n\n    mod.pos = new Sk.builtin.func(function (obj) { return Sk.abstr.objectPositive(obj); });\n    mod.__pos__ = mod.pos;\n\n    mod.pow = new Sk.builtin.func(function (a, b) { return Sk.builtin.nmber.prototype['nb$power'].call(a, b); });\n    mod.__pow__ = mod.pow;\n\n    mod.rshift = new Sk.builtin.func(function (a, b) { return Sk.builtin.nmber.prototype['nb$rshift'].call(a, b); });\n    mod.__rshift__ = mod.rshift;\n\n    mod.sub = new Sk.builtin.func(function (a, b) { return Sk.builtin.nmber.prototype['nb$subtract'].call(a, b); });\n    mod.__sub__ = mod.sub;\n\n    mod.truediv = mod.div;\n    mod.__truediv__ = mod.div;\n\n    mod.xor = new Sk.builtin.func(function (a, b) { return Sk.builtin.nmber.prototype['nb$xor'].call(a, b); });\n    mod.__xor__ = mod.xor;\n\n    mod.concat = new Sk.builtin.func(function (a, b) { return Sk.abstr.sequenceConcat(a, b); });\n    mod.__concat__ = mod.concat;\n\n    mod.contains = new Sk.builtin.func(function (a, b) { return Sk.builtin.bool(Sk.abstr.sequenceContains(a, b)); });\n    mod.__contains__ = mod.contains;\n\n    mod.countOf = new Sk.builtin.func(function (a, b) { return Sk.abstr.sequenceGetCountOf(a, b); });\n\n    mod.delitem = new Sk.builtin.func(function (a, b) { return Sk.abstr.sequenceDelItem(a, b); });\n    mod.__delitem__ = mod.delitem;\n\n    mod.getitem = new Sk.builtin.func(function (a, b) { return Sk.abstr.sequenceGetItem(a, b); });\n    mod.__getitem__ = mod.getitem;\n\n    mod.indexOf = new Sk.builtin.func(function (a, b) { return Sk.abstr.sequenceGetIndexOf(a, b); });\n\n    mod.setitem = new Sk.builtin.func(function (a, b, c) { return Sk.abstr.sequenceSetItem(a, b, c); });\n    mod.__setitem__ = mod.setitem;\n\n    return mod;\n};\n", "src/lib/simulator/setup.py": "'''\nCreated on 07.02.2014\n\n@author: tatsch\n'''\n\ndef setup():\n    from simulator.controller import Controller\n    from simulator.drone import Drone\n    from simulator.simulator import Simulator\n    import numpy as np;\n    \n    drone = Drone()\n    angular_disturbance = np.array([[0.03], [0.02], [0.1]])\n    #drone.thetadot = angular_disturbance  # Simulate some disturbance in the angular velocity.\n    controller = Controller(drone)\n    simulator = Simulator(drone,controller)\n    \n    return simulator;\n", "src/lib/unittest/__init__.py": "__author__ = 'bmiller'\n'''\nThis is the start of something that behaves like\nthe unittest module from cpython.\n\n'''\n\n\nclass TestCase:\n    def __init__(self):\n        self.numPassed = 0\n        self.numFailed = 0\n\n        self.tlist = []\n        testNames = {}\n        for name in dir(self):\n            if name[:4] == 'test' and name not in testNames:\n                self.tlist.append(getattr(self,name))\n                testNames[name]=True\n\n    def setup(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def main(self):\n\n        for func in self.tlist:\n            try:\n                self.setup()\n                func()\n                self.tearDown()\n            except:\n                self.appendResult('Error',None,None,None)\n                self.numFailed += 1\n        self.showSummary()\n\n    def assertEqual(self, actual, expected, feedback=\"\"):\n        res = actual==expected\n        self.appendResult(res,str(actual)+' to be equal to ',expected, feedback)\n\n    def assertNotEqual(actual, expected, feedback=\"\"):\n        res = actual != expected\n        self.appendResult(res,str(actual)+' to not equal ',expected,feedback)\n\n    def assertTrue(self,x, feedback=\"\"):\n        res = x\n        self.appendResult(res,str(x)+' to be ',True,feedback)\n\n    def assertFalse(self,x, feedback=\"\"):\n        res = not x\n        self.appendResult(res,str(x)+' to be ',False,feedback)\n\n    def assertIs(self,a,b, feedback=\"\"):\n        res = a is b\n        self.appendResult(res,str(a)+' to be the same object as ',b,feedback)\n\n    def assertIsNot(self,a,b, feedback=\"\"):\n        res = a is not b\n        self.appendResult(res,str(a)+' to not be the same object as ',b,feedback)\n\n    def assertIsNone(self,x, feedback=\"\"):\n        res = x is None\n        self.appendResult(res,x,None,feedback)\n\n    def assertIsNotNone(self,x, feedback=\"\"):\n        res = x is not None\n        self.appendResult(res,str(x)+' to not be ',None,feedback)\n\n    def assertIn(self,a,b, feedback=\"\"):\n        res = a in b\n        self.appendResult(res,str(a)+' to be in ',b,feedback)\n\n    def assertNotIn(self,a,b, feedback=\"\"):\n        res = a not in b\n        self.appendResult(res,str(a)+' to not be in ',b,feedback)\n\n    def assertIsInstance(self,a,b, feedback=\"\"):\n        res = isinstance(a,b)\n        self.appendResult(res,str(a)+' to be an instance of ',b,feedback)\n\n    def assertNotIsInstance(self,a,b, feedback=\"\"):\n        res = not isinstance(a,b)\n        self.appendResult(res,str(a)+' to not be an instance of ',b,feedback)\n\n    def assertAlmostEqual(self,a,b, feedback=\"\"):\n        res = round(a-b,7) == 0\n        self.appendResult(res,str(a)+' to equal ',b,feedback)\n\n    def assertNotAlmostEqual(self,a,b, feedback=\"\"):\n        res = round(a-b,7) != 0\n        self.appendResult(res,str(a)+' to not equal ',b,feedback)\n\n    def assertGreater(self,a,b, feedback=\"\"):\n        res = a > b\n        self.appendResult(res,str(a)+' to be greater than ',b,feedback)\n\n    def assertGreaterEqual(self,a,b, feedback=\"\"):\n        res = a >= b\n        self.appendResult(res,str(a)+' to be greater than or equal to ',b,feedback)\n\n    def assertLess(self,a,b, feedback=\"\"):\n        res = a < b\n        self.appendResult(res,str(a)+' to be less than ',b,feedback)\n\n    def assertLessEqual(self,a,b, feedback=\"\"):\n        res = a <= b\n        self.appendResult(res,str(a)+' to be less than or equal to ',b,feedback)\n\n    def appendResult(self,res,actual,expected,feedback):\n        if res == 'Error':\n            msg = 'Error'\n        elif res:\n            msg = 'Pass'\n            self.numPassed += 1\n        else:\n            msg = 'Fail: expected %s  %s ' % (str(actual),str(expected)) + feedback\n            self.numFailed += 1\n\n    def showSummary(self):\n        pct = self.numPassed / (self.numPassed+self.numFailed) * 100\n        print \"ran %d tests, passed %d \\n\" % (self.numPassed+self.numFailed, self.numPassed)\n\n\n\ndef main():\n    glob = globals()  # globals() still needs work\n    for name in glob:\n        if issubclass(glob[name],TestCase):\n            glob[name]().main()  \n\n", "src/lib/test/__init__.py": "__author__ = 'bmiller'\n\ndef testEqual(actual, expected):\n    if type(expected) == type(1):\n        if actual == expected:\n            print('Pass')\n            return True\n    elif type(expected) == type(1.11):\n        if abs(actual-expected) < 0.00001:\n            print('Pass')\n            return True\n    else:\n        if actual == expected:\n            print('Pass')\n            return True\n    print('Test Failed: expected ' + str(expected) + ' but got ' + str(actual))\n    return False\n\ndef testNotEqual(actual, expected):\n    pass\n\n", "src/lib/string/__init__.js": "/*\n *  __author__: Isaac Dontje Lindell (i@isaacdontjelindell.com)\n *\n *  Implementation of the Python string module.\n */\n\n\nvar $builtinmodule = function(name) {\n    var mod = {};\n\n    mod.ascii_lowercase = Sk.builtin.str('abcdefghijklmnopqrstuvwxyz');\n    mod.ascii_uppercase = Sk.builtin.str('ABCDEFGHIJKLMNOPQRSTUVWXYZ');\n    mod.ascii_letters = Sk.builtin.str(mod.ascii_lowercase.v + mod.ascii_uppercase.v);\n\n    mod.lowercase = Sk.builtin.str('abcdefghijklmnopqrstuvwxyz');\n    mod.uppercase = Sk.builtin.str('ABCDEFGHIJKLMNOPQRSTUVWXYZ');\n    mod.letters = Sk.builtin.str(mod.lowercase.v + mod.uppercase.v);\n\n    mod.digits = Sk.builtin.str('0123456789', Sk.builtin.str);\n    mod.hexdigits = Sk.builtin.str('0123456789abcdefABCDEF');\n    mod.octdigits = Sk.builtin.str('01234567');\n\n    mod.punctuation = Sk.builtin.str('!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~');\n    mod.whitespace = Sk.builtin.str('\\t\\n\\x0b\\x0c\\r ');\n\n    /* Note: The docs for string.printable say that it's the concatenation of string.digits,\n     * string.letters, string.punctuation, and string.whitespace. The CPython interpreter\n     * outputs the whitespace characters in one order when string.whitespace is used, and a\n     * slightly different order when string.printable is used. I've elected to follow the\n     * behavior of CPython here rather than the spec. */\n    mod.printable = Sk.builtin.str(mod.digits.v + mod.letters.v + mod.punctuation.v + \" \\t\\n\\r\\x0b\\x0c\");\n\n\n    mod.split = new Sk.builtin.func(function(s, sep, maxsplit) {\n        return Sk.misceval.callsim(Sk.builtin.str.prototype['split'], s, sep, maxsplit);\n    });\n\n    /* Return a copy of word with only its first character capitalized. */\n    mod.capitalize = new Sk.builtin.func(function(word) {\n        return Sk.misceval.callsim(Sk.builtin.str.prototype['capitalize'], word);\n    });\n\n    /* Concatenate a list or tuple of words with intervening occurrences\n     * of sep. The default value for sep is a single space character. */\n    mod.join = new Sk.builtin.func(function(words, sep) {\n        if (sep === undefined) {\n            sep = Sk.builtin.str(' ');\n        }\n        return Sk.misceval.callsim(Sk.builtin.str.prototype['join'], sep, words);\n    });\n\n\n    /* Split the argument into words using split(), capitalize each word\n     * using capitalize(), and join the capitalized words using join().\n     * Note that this replaces runs of whitespace characters by a single\n     * space, and removes leading and trailing whitespace. */\n    mod.capwords = new Sk.builtin.func(function(s, sep) {\n        Sk.builtin.pyCheckArgs('capwords', arguments, 1, 2);\n        if (!Sk.builtin.checkString(s)) {\n            throw new Sk.builtin.TypeError(\"s must be a string\");\n        }\n        if (sep === undefined) {\n            sep = Sk.builtin.str(' ');\n        }\n        if(!Sk.builtin.checkString(sep)) {\n            throw new Sk.builtin.TypeError(\"sep must be a string\");\n        }\n\n        var words = Sk.misceval.callsim(mod.split, s, sep);\n        var capWords = [];\n        for (var i=0; i<words.v.length; i++) {\n            var word = Sk.builtin.list.prototype['list_subscript_'].call(words, i);\n            var cap = Sk.misceval.callsim(mod.capitalize, word);\n            capWords.push(cap);\n        }\n\n        return Sk.misceval.callsim(mod.join, Sk.builtin.list(capWords), sep);\n    });\n\n\n    return mod;\n};", "src/builtin/sys.js": "var $builtinmodule = function(name)\n{\n    var sys = {};\n\n    var args = [];\n    var argv = Sk.getSysArgv();\n    for (var i = 0; i < argv.length; ++i)\n        args.push(new Sk.builtin.str(argv[i]));\n    sys.argv = new Sk.builtins['list'](args);\n\n    sys.copyright = Sk.builtin['str'](\"Copyright 2009-2010 Scott Graham.\\nAll Rights Reserved.\\n\");\n    sys.platform = Sk.builtin['str'](\"skulpt\");\n\n\n    sys.modules = Sk.sysmodules;\n\n    sys.path = Sk.realsyspath;\n\n    sys.getExecutionLimit = new Sk.builtin.func(function() {\n        return Sk.builtin.assk$(Sk.execLimit, Sk.builtin.nmber.int$);\n    });\n\n    sys.setExecutionLimit = new Sk.builtin.func(function(t) {\n        if (t !==  undefined) {\n            Sk.execLimit = Sk.builtin.asnum$(t);\n        }\n    });\n\n    sys.resetTimeout = new Sk.builtin.func(function() {\n        Sk.execStart = new Date();\n    });\n\n    sys.debug = new Sk.builtin.func(function() {\n        debugger;\n    });\n\n    return sys;\n};\n", "src/lib/quadrotor/command.py": "from simulator.controller import RelativeOrder\n\ndef forward(distance):\n    return RelativeOrder(distance, 0, 0, 0)\n\ndef backward(distance):\n    return RelativeOrder(-distance, 0, 0, 0)\n\ndef left(distance):\n    return RelativeOrder(0, distance, 0, 0)\n\ndef right(distance):\n    return RelativeOrder(0, -distance, 0, 0)\n\ndef up(distance):\n    return RelativeOrder(0, 0, distance, 0)\n\ndef down(distance):\n    return RelativeOrder(0, 0, -distance, 0)\n\ndef turn_left(angle):\n    return RelativeOrder(0, 0, 0, angle)\n\ndef turn_right(angle):\n    return RelativeOrder(0, 0, 0, -angle)\n", "src/lib/simulator/__init__.py": "", "src/lib/simulator/main.py": "import numpy as np\nfrom controller import Controller\nfrom drone import Drone\nfrom simulator import Simulator\n\ndef run():\n    drone = Drone()\n    controller = Controller(drone)\n    simulator = Simulator(drone, controller)\n    deviation = 1;   # Simulate some disturbance in the angular velocity.\n    #angular_disturbance=simulator.deg2rad(2 * deviation * np.random.rand(3, 1) - deviation).transpose()\n    angular_disturbance = np.array([[0.0],[0.1],[0.0]])\n    #drone.thetadot = angular_disturbance  # Simulate some disturbance in the angular velocity.\n    simulator.simulate(60)  # simulate n secs\n    \n    import matplotlib.pyplot\n    matplotlib.pyplot.pause(60)\nrun()", "src/lib/plot/__init__.js": "var $builtinmodule = function(name)\n{\n  Sk.interop['plot'] = Sk.interop['plot'] || {\n    'data': {\n      'scalar': {},\n      'pose': {},\n      'motor_command': {},\n      'trajectory': {},\n      'points': {},\n      'covariance2d': {},\n      'covariance3d': {},\n    }\n  };\n\n  var plot = Sk.interop['plot'];\n\n  plot['clear'] = function() {\n    Object.keys(plot.data).forEach(function(type) {\n      Object.keys(plot.data[type]).forEach(function(name) {\n        plot.data[type][name] = [];\n      });\n    });\n  };\n  plot['reset'] = function() {\n    Object.keys(plot.data).forEach(function(type) {\n      plot.data[type] = {};\n    });\n  };\n\n  var addPlotValue = function(type, name, value) {\n    if (plot.data[type][name] == undefined) {\n        plot.data[type][name] = [];\n    }\n\n    plot.data[type][name].push(value);\n  };\n\n  var mod = {};\n\n  mod.plot = new Sk.builtin.func(function(name, value) {\n    Sk.builtin.pyCheckArgs('plot', arguments, 2);\n    Sk.builtin.pyCheckType('name', 'string', Sk.builtin.checkString(name));\n    Sk.builtin.pyCheckType('value', 'number', Sk.builtin.checkNumber(value));\n\n    addPlotValue('scalar', name.v, value.v);\n  });\n\n  mod.plot_pose = new Sk.builtin.func(function(name, position, orientation) {\n    Sk.builtin.pyCheckArgs('plot_pose', arguments, 3);\n    Sk.builtin.pyCheckType('name', 'string', Sk.builtin.checkString(name));\n\n    addPlotValue('pose', name.v, [position.v.get([0, 0]), position.v.get([1, 0]), position.v.get([2, 0]), orientation.v.get([0, 0]), orientation.v.get([1, 0]), orientation.v.get([2, 0])]);\n  });\n\n  mod.plot_motor_command = new Sk.builtin.func(function(name, value) {\n    Sk.builtin.pyCheckArgs('plot_motor_command', arguments, 2);\n    Sk.builtin.pyCheckType('name', 'string', Sk.builtin.checkString(name));\n\n    addPlotValue('motor_command', name.v, [value.v.get([0, 0]), value.v.get([1, 0]), value.v.get([2, 0]), value.v.get([3, 0])]);\n  });\n\n  mod.plot_trajectory = new Sk.builtin.func(function(name, position) {\n    Sk.builtin.pyCheckArgs('plot_trajectory', arguments, 2);\n    Sk.builtin.pyCheckType('name', 'string', Sk.builtin.checkString(name));\n\n    var size = position.v.size();\n\n    addPlotValue('trajectory', name.v, [position.v.get([0, 0]), position.v.get([1, 0]), size[0] > 2 ? position.v.get([2, 0]) : 0]);\n  });\n\n  mod.plot_point = new Sk.builtin.func(function(name, position) {\n    Sk.builtin.pyCheckArgs('plot_point', arguments, 2);\n    Sk.builtin.pyCheckType('name', 'string', Sk.builtin.checkString(name));\n\n    var size = position.v.size();\n\n    addPlotValue('points', name.v, [position.v.get([0, 0]), position.v.get([1, 0]), size[0] > 2 ? position.v.get([2, 0]) : 0]);\n  });\n\n  mod.plot_covariance_2d = new Sk.builtin.func(function(name, cov) {\n    Sk.builtin.pyCheckArgs('plot_covariance_2d', arguments, 2, 2);\n    Sk.builtin.pyCheckType('name', 'string', Sk.builtin.checkString(name));\n\n    addPlotValue('covariance2d', name.v, cov.v.toArray());\n  });\n\n  mod.plot_covariance_3d = new Sk.builtin.func(function(name, cov) {\n    Sk.builtin.pyCheckArgs('plot_covariance_3d', arguments, 2, 2);\n    Sk.builtin.pyCheckType('name', 'string', Sk.builtin.checkString(name));\n\n    addPlotValue('covariance3d', name.v, cov.v.toArray());\n  });\n\n  return mod;\n};\n", "src/lib/simulator/drone.py": "'''\nCreated on 07.02.2014\n\n@author: tatsch\n'''\nimport numpy as np\n\n#Drone layout\n#\n#          1 O\n#            |\n#        x ^ |\n#          | |\n#            |          4\n# O----------+----------O\n# 2   <--    |\n#      y     |\n#            |\n#            |\n#            O 3\n\nclass Drone():\n    '''\n    Model the drone\n    '''\n\n    #As in \"Modeling Ardrone\"\n    L = 0.18  # distance between prop and COG in m\n    m = 436.5  # mass of the drone in g\n    g = 980.66  # gm/s^2\n    I = np.array([[2.04016E-2, 0, 0],\n                  [0, 1.56771E-2, 0],\n                  [0, 0, 3.51779E-2]])  # inertia matrix of the drone in gm3\n\n    k_b = 3.29E-11 # drag coefficient Nm/rpm2\n    k_t =  1.27E-7  # torque coefficient\n    kd = 0.1  # air friction coefficent of the whole ardrone,\n\n    #As in Hector Quadrotor Simulator\n    #Psi:  0.007242179827506\n    #J_M: 2.573048063300000e-5 #inertia Motor\n    #R_A: 0.201084219222241 #resistance motor\n    #k_t: 0.015336864714397 #m_m=k_t*T\n    #k_m: -7.011631909766668e-5\n    #alpha_m: 0.104863758313889\n    #beta_m: 0.549262344777900\n    #CT2s: -1.3077e-2 #Thrust koefficients k_t from a  quadratic model\n    #CT1s: -2.5224e-4\n    #CT0s:  1.538190483976698e-5\n    #l_m: 0.275\n\n    L = 0.18  # distance between prop and COG in m\n    m = 0.4365  # mass of the drone in kg, for hovering 5.8 A\n    g = 9.81  # gm/s^2\n    I = np.array([[2.5730480633e-8, 0, 0],\n                  [0, 2.573048063300000e-8, 0],\n                  [0, 0, 2.573048063300000e-5]])  # inertia matrix of the drone in gm3\n    I = np.array([[0.007, 0, 0],\n                  [0, 0.007, 0],\n                  [0, 0, 0.012]])  # inertia matrix of the drone in gm3\n    k_b = 0.1 # drag coefficient Nm/rpm2\n    k_t =  0.73  # thrust coefficient in g/\n    kd = 0.12  # air friction coefficent of the whole ardrone,\n\n    x = np.array([[0.0],\n                  [0.0],\n                  [0.0]])\n    xdot = np.zeros((3, 1))\n    xdoubledot = np.zeros((3, 1))\n\n    theta = np.zeros((3, 1))\n    theta_body = np.zeros((3, 1))\n    thetadot = np.zeros((3, 1))\n    thetadoubledot = np.zeros((3, 1))\n\n    def __init__(self):\n        self.I_inv = np.linalg.inv(self.I)\n\n        # K matrix is diagonal containing constants\n        # A matrix is allocation matrix describing configuration of quadrotor\n\n        k = self.k_t\n        kL = k * self.L\n        b = self.k_b\n        m = self.m\n        Ixx = self.I.item((0, 0))\n        Iyy = self.I.item((1, 1))\n        Izz = self.I.item((2, 2))\n\n        # matrix to compute torques/moments and thrust from motor inputs\n        self.KA = np.array([[0.0,kL,0.0,-kL],[kL,0.0,-kL,0.0],[b,-b,b,-b],[k,k,k,k]])\n        #self.KA = np.array([[0,-kL,0,kL],[kL,0,-kL,0],[b,-b,b,-b],[k,k,k,k]]);\n        # matrix to compute motor inputs from desired angular acceleration and thrust\n        self.AinvKinvI = np.array([[0.0,Iyy/(2.0*kL),Izz/(4.0*b),m/(4.0*k)],[Ixx/(2.0*kL),0.0,-Izz/(4.0*b),m/(4.0*k)],[0.0,-Iyy/(2.0*kL),Izz/(4.0*b),m/(4.0*k)],[-Ixx/(2.0*kL),0.0,-Izz/(4.0*b),m/(4.0*k)]])\n        #self.AinvKinvI = np.array([[0,Iyy/(2*kL),Izz/(4*b),m/(4*k)],[-Ixx/(2*kL),0,-Izz/(4*b),m/(4*k)],[0,-Iyy/(2*kL),Izz/(4*b),m/(4*k)],[Ixx/(2*kL),0,-Izz/(4*b),m/(4*k)]]);\n\n\n        # H configuration\n        #self.KA = np.array([[kL,kL,-kL,-kL],[kL,-kL,-kL,kL],[-b,b,-b,b],[k,k,k,k]])\n        #self.AinvKinvI = np.array([[Ixx/(4*kL),Iyy/(4*kL),-Izz/(4*b),m/(4*k)],[Ixx/(4*kL),-Iyy/(4*kL),Izz/(4*b),m/(4*k)],[-Ixx/(4*kL),-Iyy/(4*kL),-Izz/(4*b),m/(4*k)],[-Ixx/(4*kL),Iyy/(4*kL),Izz/(4*b),m/(4*k)]])\n\n        self.K = np.array([[kL, 0, 0, 0],\n                           [0, kL, 0, 0],\n                           [0,  0, b, 0],\n                           [0,  0, 0, k]])\n\n        self.A = np.array([[ 1, 1,-1,-1],\n                           [ 1,-1,-1, 1],\n                           [-1, 1,-1, 1],\n                           [ 1, 1, 1, 1]])\n\n        tmp = np.array([[Ixx, 0, 0, 0],\n                        [0, Iyy, 0, 0],\n                        [0, 0, Izz, 0],\n                        [0, 0, 0, m  ]])\n\n        self.KA = np.dot(self.K, self.A);\n        self.AinvKinvI = np.dot(np.dot(np.linalg.inv(self.A), np.linalg.inv(self.K)), tmp)\n\n        # corke tutorial\n        #self.KA = np.array([[0,kL,0,-kL],[-kL,0,kL,0],[-b,b,-b,b],[k,k,k,k]]);\n        #self.AinvKinvI = np.array([[0,-Iyy/(2*kL),-Izz/(4*b),m/(4*k)],[Ixx/(2*kL),0,Izz/(4*b),m/(4*k)],[0,Iyy/(2*kL),-Izz/(4*b),m/(4*k)],[-Ixx/(2*kL),0,Izz/(4*b),m/(4*k)]]);\n\n        pass\n\n    def angle_rotation_to_body(self):\n        '''\n        compute rotation matrix to convert angular velocities to body frame\n        '''\n        from math import sin, cos\n\n        phi = self.theta.item(0);\n        theta = self.theta.item(1);\n\n        #return np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\n        return np.array([[1, 0, -sin(theta)],\n                      [0, -cos(phi), cos(theta) * sin(phi)],\n                      [0, sin(phi), cos(theta) * cos(phi)]])\n\n\n    def yaw_rotation(self):\n        '''\n        compute rotation matrix to convert angular velocities to body frame\n        '''\n        from math import sin, cos\n\n        psi = self.theta.item(2);\n        cpsi = cos(psi)\n        spsi = sin(psi)\n        return np.array([[cpsi, -spsi, 0],\n                      [spsi, cpsi, 0],\n                      [0, 0, 1]])\n\n    def angle_rotation_to_world(self):\n        '''\n        compute rotation matrix to convert angular velocities to world frame\n        '''\n        from math import sin, cos, tan, fabs\n\n        phi = self.theta.item(0);\n        theta = self.theta.item(1);\n        #return np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\n        return np.array([[1, sin(phi) * tan(theta), cos(phi) * tan(theta)],\n                      [0, cos(phi), -sin(phi)],\n                      [0, sin(phi) / cos(theta), cos(phi) / cos(theta)]])\n\n    def theta_in_body(self):\n        return np.dot(self.angle_rotation_to_body(), self.theta)\n\n    def thetadot_in_body(self):\n        return np.dot(self.angle_rotation_to_body(), self.thetadot)\n\n    def torques_thrust(self, inputs):\n        return np.dot(self.KA, inputs)\n\n    # Compute motor torques, given the current input currents, length, drag coefficient, and thrust coefficients\n    def torques(self, inputs):\n        mu = np.array([[self.L * self.k_t, 0,                 0],\n                       [0,              self.L * self.k_t,    0],\n                       [0,              0,                  self.k_b]])\n        inp = np.array([[inputs[0] - inputs[2]],\n                        [inputs[1] - inputs[3]],\n                        [inputs[0] - inputs[1] + inputs[2] - inputs[3]]])\n        tau = np.dot(mu, inp)\n        return tau\n\n    def thrust(self, inputs):\n        T = np.array([[0], [0], [self.k_t * sum(inputs)]])\n        return T\n\n    def rotation(self):  # translate angles to intertial/world frame\n        import math\n        phi = self.theta.item(0)\n        theta = self.theta.item(1)\n        psi = self.theta.item(2)\n\n        c_phi = math.cos(phi);\n        s_phi = math.sin(phi);\n        c_theta = math.cos(theta);\n        s_theta = math.sin(theta);\n        c_psi = math.cos(psi)\n        s_psi = math.sin(psi)\n\n        #ZYZ Euler nach Paper\n        #R = np.array([[c_phi * c_psi - c_theta * s_phi * s_psi, -c_psi * s_phi - c_phi * c_theta * s_psi, s_theta * s_psi],\n        #              [c_theta * c_psi * s_phi + c_phi * s_psi, c_phi * c_theta * c_psi - s_phi * s_psi,  -c_psi * s_theta],\n        #              [s_phi * s_theta, c_phi * s_theta, c_theta]])\n        # Master thesis XYZ\n        R = np.array([[c_psi * c_theta, c_psi * s_theta * s_phi - s_psi * c_phi, c_psi * s_theta * c_phi + s_psi * s_phi],\n                      [s_psi * c_theta, s_psi * s_theta * s_phi + c_psi * c_phi, s_psi * s_theta * c_phi - c_psi * s_phi],\n                      [-s_theta, c_theta * s_phi, c_theta * c_phi]])\n\n        #ZYZ Euler nach craig\n        #R = np.array([[math.cos(psi)*math.cos(theta)*math.cos(phi)-math.sin(psi)*math.sin(phi), -math.cos(psi)*math.cos(theta)*math.sin(phi)-math.sin(psi)*math.cos(phi), math.cos(psi)*math.sin(theta) ],\n        #              [math.sin(psi)*math.cos(theta)*math.cos(phi)+math.cos(psi)*math.sin(phi), -math.sin(psi)*math.cos(theta)*math.sin(phi)+math.cos(psi)*math.cos(phi), math.sin(psi)*math.sin(theta) ],\n        #              [-math.sin(theta)*math.cos(phi), math.sin(theta)*math.sin(phi), math.cos(theta)]])\n\n        return R\n", "src/lib/numpy/__init__.js": "var $builtinmodule = function(name) {\n\tvar math = Sk.interop['mathjs']();\n\tvar mod = {};\n\tvar printPrecision=5;\n\n\tfunction toNativeArray(value) {\n\t\tif(Object.prototype.toString.call(value.v) === '[object Array]') {\n\t\t\tvar result = [];\n\t\t\tvar idx;\n\n\t\t\tfor(idx = 0; idx < value.v.length; ++idx) {\n\t\t\t\tresult[idx] = toNativeArray(value.v[idx]);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn value.v;\n\t\t}\n\t};\n\n\t// transform tuple/slices to index arrays\n\tfunction toNativeIndex(idx) {\n\t\tif(idx.tp$name === 'tuple') {\n\t\t\tvar result = [];\n\t\t\tvar i, submatrix = false, indices = [];\n\n\t\t\tfor(i = 0; i < idx.v.length; ++i) {\n\t\t\t\tvar tmp = toNativeIndex(idx.v[i]);\n\n\t\t\t\tsubmatrix = submatrix || tmp.submatrix;\n\t\t\t\tindices = indices.concat(tmp.indices);\n\t\t\t}\n\n\t\t\treturn { 'submatrix': submatrix, 'indices': indices };\n\t\t} else {\n\t\t\tif(idx.tp$name === 'number') {\n\t\t\t\treturn { submatrix: false, indices: [idx.v]};\n\t\t\t}\n\n\t\t\tif(idx.tp$name === 'slice') {\n\t\t\t\treturn { submatrix: true, indices: [new math.type.Range(idx.start.v, idx.stop.v, idx.step.v !== null ? idx.step.v : 1)] };\n\t\t\t}\n\t\t}\n\t}\n\n\t// convert a linear index to a mathjs index array\n\tfunction linearToNativeIndex(size, idx) {\n\t\tvar i, remainder = idx, total = 1, indices = [];\n\n\t\tfor(i = size.length - 1; i >= 0 ; --i) {\n\t\t\tindices[i] = remainder % size[i];\n\t\t\tremainder = Math.floor(remainder / size[i]);\n\t\t\ttotal *= size[i];\n\t\t}\n\n\t\treturn { 'indices': indices, 'total': total };\n\t}\n\n\t// translate negative indices/add missing dimensions\n\tfunction normalizeNativeIndex(size, idx) {\n\t\tif(size.length < idx.indices.length) {\n\t\t\tthrow new Sk.builtin.IndexError('invalid index (number of indices is larger than ndarray.ndims)');\n\t\t}\n\n\t\tvar i;\n\t\tfor(i = 0; i < idx.indices.length; ++i) {\n\t\t\tif(math.type.Range.isRange(idx.indices[i])) {\n\t\t\t\t// clamp range\n\t\t\t\tif(idx.indices[i].end > size[i]) {\n\t\t\t\t\tidx.indices[i].end = size[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// translate negative indices\n\t\t\t\tif(idx.indices[i] < 0) {\n\t\t\t\t\tidx.indices[i] = size[i] + idx.indices[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add missing dimensions\n\t\tif(size.length > idx.indices.length) {\n\t\t\tvar i;\n\t\t\tfor(i = idx.indices.length; i < size.length; ++i) {\n\t\t\t\tif(size[i] > 1) {\n\t\t\t\t\tidx.indices[i] = new math.type.Range(0, size[i]);\n\t\t\t\t\tidx.submatrix = true\n\t\t\t\t} else {\n\t\t\t\t\tidx.indices[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn idx;\n\t}\n\n\t/**\n\tndarray class\n\tTODO: can we make it iterable?\n\t*/\n\tvar ndarray = function($gbl, $loc) {\n\t\t$loc.__init__ = new Sk.builtin.func(function(self, shape, data) {\n\t\t\tSk.builtin.pyCheckArgs('numpy.ndarray.__init__', arguments, 2, 3);\n\n\t\t\tif(shape !== undefined) {\n\n\t\t\t\ttry {\n\t\t\t\t\tself.v = math.matrix(toNativeArray(data));\n\t\t\t\t} catch(e) {\n\t\t\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t\t\t}\n\n\t\t\t\t// TODO: check shape\n\t\t\t} else {\n\t\t\t\t// TODO: better implementation of wrapping mathjs object in python ndarray\n\t\t\t\tself.v = data;\n\t\t\t}\n\t\t});\n\n\t\t$loc.__getitem__ = new Sk.builtin.func(function(self, key) {\n\t\t\tvar idx = normalizeNativeIndex(self.v.size(), toNativeIndex(key));\n\n\t\t\ttry {\n\t\t\t\tif(idx.submatrix) {\n\t\t\t\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, self.v.subset(math.type.Index.create(idx.indices)));\n\t\t\t\t} else {\n\t\t\t\t\treturn Sk.builtin.nmber(self.v.get(idx.indices), Sk.builtin.nmber.float$);\n\t\t\t\t}\n\t\t\t} catch(e) {\n\t\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t\t}\n\t\t});\n\n\t\t$loc.__setitem__ = new Sk.builtin.func(function(self, key, value) {\n\t\t\tvar idx = normalizeNativeIndex(self.v.size(), toNativeIndex(key));\n\n\t\t\ttry {\n\t\t\t\tif(idx.submatrix) {\n\t\t\t\t\tself.v.subset(math.type.Index.create(idx.indices), value.v);\n\t\t\t\t} else {\n\t\t\t\t\tself.v.set(idx.indices, value.v);\n\t\t\t\t}\n\t\t\t} catch(e) {\n\t\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t\t}\n\t\t});\n\n\t\t$loc.__add__ = new Sk.builtin.func(function(self, other) {\n\t\t\treturn Sk.misceval.callsim(mod.add, self, other);\n\t\t});\n\n\t\t$loc.__iadd__ = new Sk.builtin.func(function(self, other) {\n\t\t\tself.v = Sk.misceval.callsim(mod.add, self, other).v;\n\t\t\treturn self\n\t\t});\n\n\t\t$loc.__sub__ = new Sk.builtin.func(function(self, other) {\n\t\t\treturn Sk.misceval.callsim(mod.subtract, self, other);\n\t\t});\n\n\t\t$loc.__isub__ = new Sk.builtin.func(function(self, other) {\n\t\t\tself.v = Sk.misceval.callsim(mod.subtract, self, other).v;\n\t\t\treturn self\n\t\t});\n\n\t\t$loc.__mul__ = new Sk.builtin.func(function(self, other) {\n\t\t\treturn Sk.misceval.callsim(mod.multiply, self, other);\n\t\t});\n\n\t\t$loc.__imul__ = new Sk.builtin.func(function(self, other) {\n\t\t\tself.v = Sk.misceval.callsim(mod.multiply, self, other).v;\n\t\t\treturn self\n\t\t});\n\n\t\t$loc.__rmul__ = $loc.__mul__;\n\n\t\t$loc.__div__ = new Sk.builtin.func(function(self, other) {\n\t\t\treturn Sk.misceval.callsim(mod.divide, self, other);\n\t\t});\n\n\t\t$loc.__idiv__ = new Sk.builtin.func(function(self, other) {\n\t\t\tself.v = Sk.misceval.callsim(mod.divide, self, other).v;\n\t\t\treturn self\n\t\t});\n\n\t\t/*\n\t\tTODO: Skulpt doesn't call __pos__\n\t\t$loc.__pos__ = new Sk.builtin.func(function(self) {\n\t\t\treturn self;\n\t\t});\n\t\t*/\n\n\t\t$loc.nb$positive = function() {\n\t\t\treturn this;\n\t\t};\n\n\t\t/*\n\t\t* TODO: Skulpt doesn't call __neg__\n\t\t$loc.__neg__ = new Sk.builtin.func(function(self) {\n\t\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, math.unary(self.v));\n\t\t});\n\t\t*/\n\n\t\t$loc.nb$negative = function() {\n\t\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, math.unary(this.v));\n\t\t};\n\n\t\t$loc.transpose = new Sk.builtin.func(function(self) {\n\t\t\treturn Sk.misceval.callsim(mod.transpose, self);\n\t\t});\n\n\t\t$loc.inv = new Sk.builtin.func(function(self) {\n\t\t\treturn Sk.misceval.callsim(mod.inv, self);\n\t\t});\n\n\t\t$loc.item = new Sk.builtin.func(function(self, key) {\n\t\t\tvar idx = { submatrix: false, indices: [] };\n\n\t\t\tif(key === undefined) {\n\t\t\t\tvar tmp = linearToNativeIndex(self.v.size(), 0)\n\n\t\t\t\tif(tmp.total !== 1) {\n\t\t\t\t\tthrow new Sk.builtin.ValueError('can only convert an array  of size 1 to a Python scalar');\n\t\t\t\t}\n\n\t\t\t\tidx.indices = tmp.indices;\n\t\t\t} else if(key.tp$name === 'number' && key.skType == 'int') {\n\t\t\t\tvar tmp = linearToNativeIndex(self.v.size(), key.v)\n\n\t\t\t\tif(key.v < 0 || key.v >= tmp.total) {\n\t\t\t\t\tthrow new Sk.builtin.ValueError('index out of bounds');\n\t\t\t\t}\n\n\t\t\t\tidx.indices = tmp.indices;\n\t\t\t} else if(key.tp$name === 'tuple') {\n\t\t\t\tidx = normalizeNativeIndex(self.v.size(), toNativeIndex(key));\n\t\t\t} else {\n\t\t\t\tthrow new Sk.builtin.Exception('invalid index argument of type \"' + key.tp$name + '\" for ndarray.item()!');\n\t\t\t}\n\n\t\t\tif(idx.submatrix) {\n\t\t\t\tthrow new Sk.builtin.Exception('ndarray.item() can only be used to access scalar values!');\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\treturn Sk.builtin.nmber(self.v.get(idx.indices), Sk.builtin.nmber.float$);\n\t\t\t} catch(e) {\n\t\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t\t}\n\t\t});\n\n\n\t\t$loc.__getattr__ = new Sk.builtin.func(function(self, attr) {\n\t\t\tif(attr == 'ndim') return Sk.builtin.nmber(self.v.size().length, Sk.builtin.nmber.int$)\n\t\t\tif(attr == 'shape') return Sk.builtin.tuple(self.v.size())\n\t\t\tif(attr == 'T') return Sk.misceval.callsim(mod.transpose, self);\n\t\t\treturn self.tp$getattr(attr);\n\t\t});\n\n\t\t$loc.__str__ = new Sk.builtin.func(function(self) {\n\t\t\treturn Sk.misceval.callsim(mod.array_str, self);\n\t\t});\n\t};\n\tmod.ndarray = Sk.misceval.buildClass(mod, ndarray, 'ndarray', []);\n\n\t/**\n\t * linalg package\n\t */\n\t// TODO: this is still not the right way\n\tmod.linalg = new Sk.builtin.module();\n\tmod.linalg['$d'] = {\n\t\t__name__:  Sk.builtin.str('numpy.linalg'),\n\t\tinv: new Sk.builtin.func(function(array1) {\n\t\t\tSk.builtin.pyCheckArgs('inv', arguments, 1);\n\n\t\t\tvar result;\n\t\t\ttry {\n\t\t\t\tresult = math.inv(array1.v);\n\t\t\t} catch(e) {\n\t\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t\t}\n\t\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t\t}),\n\t};\n\t\n\t/**\n\t * random package\n\t */\n\t \n\tvar normal_dist = math.distribution('normal') \n\tmod.random = new Sk.builtin.module();\n\tmod.random['$d'] = {\n\t\t__name__:  Sk.builtin.str('numpy.linalg'),\n\t\trandom: new Sk.builtin.func(function(shape) {\n\t\t\tSk.builtin.pyCheckArgs('random', arguments, 1, 1);\n\t\t\tvar s = toValidShape(shape);\n\n\t\t\tvar result;\n\t\t\ttry {\n\t\t\t\tvar mat=math.zeros(s.rows, s.cols);\n\t\t\t\tresult = mat.map(function (value, index, v) {\n\t\t\t\t\treturn math.random(0, 1);\n\t\t\t\t});\n\t\t\t} catch(e) {\n\t\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t\t}\n\t\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t\t}),\n\t\tnormal: new Sk.builtin.func(function(mu, sigma, shape) {\n\t\t\tSk.builtin.pyCheckArgs('normal', arguments, 0, 3);\n\t\t\tvar mean = mu !== undefined ? mu.v : 0.0;\n\t\t\tvar std = sigma !== undefined ? sigma.v : 1.0;\n\t\t\tstd *= 6.0; // mathjs uses sigma 1/6\n\t\t\tmean -= std * 0.5; // mathjs uses mean 0.5\n\t\t\tvar s = toValidShape(shape);\n\t\t\n\t\t\tvar result;\n\t\t\ttry {\n\t\t\t\tresult = math.add(math.emultiply(normal_dist.random([s.rows, s.cols]), std), mean)\n\t\t\t} catch(e) {\n\t\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t\t}\n\t\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t\t})\n\t};\n\n\t/**\n\t * creation functions\n\t */\n\tmod.array = new Sk.builtin.func(function(data) {\n\t\tSk.builtin.pyCheckArgs('array', arguments, 1);\n\n\t\treturn Sk.misceval.callsim(mod.ndarray, Sk.builtin.tuple(), data);\n\t});\n\t\n\tfunction toValidShape(size) {\n\t\tvar rows = 1, cols = 1;\n\t\t\n\t\tif(size.tp$name === 'number') {\n\t\t\trows = size.v\n\t\t} else {\n\t\t\tif(size.v.length > 0) {\n\t\t\t\trows = size.v[0].v\n\t\t\t}\n\t\t\tif(size.v.length > 1) {\n\t\t\t\tcols = size.v[1].v\n\t\t\t}\n\t\t}\n\t\treturn { 'rows': rows, 'cols': cols };\n\t}\n\n\tmod.zeros = new Sk.builtin.func(function(shape) {\n\t\tSk.builtin.pyCheckArgs('zeros', arguments, 1);\n\t\tvar s = toValidShape(shape);\n\t\t\n\t\tvar result = math.zeros(s.rows, s.cols);\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\tmod.ones = new Sk.builtin.func(function(shape) {\n\t\tSk.builtin.pyCheckArgs('ones', arguments, 1);\n\t\tvar s = toValidShape(shape);\n\t\tvar result = math.ones(s.rows, s.cols);\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\tmod.identity = new Sk.builtin.func(function(n) {\n\t\tSk.builtin.pyCheckArgs('identity', arguments, 1);\n\n\t\tvar result = math.eye(n.v);\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\tmod.arange = new Sk.builtin.func(function(start,end,step) {\n\t\tSk.builtin.pyCheckArgs('arange', arguments, 3);\n\n\t\tvar result;\n\t\ttry {\n\t\t\tresult = math.range(start.v,end.v,step.v);\n\t\t} catch(e) {\n\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t}\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\tmod.copy = new Sk.builtin.func(function(other) {\n\t\tSk.builtin.pyCheckArgs('copy', arguments, 1, 1);\n\t\tvar result;\n\t\ttry {\n\t\t\tresult=math.clone(other.v);\n\t\t} catch(e) {\n\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t}\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\t/**\n\t * arithmetic functions\n\t */\n\tmod.add = new Sk.builtin.func(function(array1, array2) {\n\t\tSk.builtin.pyCheckArgs('add', arguments, 2);\n\n\t\tvar result;\n\t\ttry {\n\t\t\tresult = math.add(array1.v, array2.v);\n\t\t} catch(e) {\n\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t}\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\tmod.subtract = new Sk.builtin.func(function(array1, array2) {\n\t\tSk.builtin.pyCheckArgs('subtract', arguments, 2);\n\n\t\tvar result;\n\t\ttry {\n\t\t\tresult = math.subtract(array1.v, array2.v);\n\t\t} catch(e) {\n\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t}\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\tmod.multiply = new Sk.builtin.func(function(array1, array2) {\n\t\tSk.builtin.pyCheckArgs('multiply', arguments, 2);\n\n\t\tvar result;\n\t\ttry {\n\t\t\tresult = math.emultiply(array1.v, array2.v);\n\t\t} catch(e) {\n\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t}\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\tmod.divide = new Sk.builtin.func(function(array1, array2) {\n\t\tSk.builtin.pyCheckArgs('divide', arguments, 2);\n\n\t\tvar result;\n\t\ttry {\n\t\t\tresult = math.edivide(array1.v, array2.v);\n\t\t} catch(e) {\n\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t}\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\tmod.dot = new Sk.builtin.func(function(array1, array2) {\n\t\tSk.builtin.pyCheckArgs('dot', arguments, 2);\n\n\t\tvar result;\n\t\ttry {\n\t\t\tresult = math.multiply(array1.v, array2.v);\n\t\t} catch(e) {\n\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t}\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\tmod.cross = Sk.nativejs.func(function(x, y, axisa, axisb, axisc, axis) {\n\t\tSk.builtin.pyCheckArgs('cross', arguments, 2);\n\n\t\tif(axisa) throw new Sk.builtin.Exception(\"argument axisa is not supported\");\n\t\tif(axisb) throw new Sk.builtin.Exception(\"argument axisb is not supported\");\n\t\tif(axisc) throw new Sk.builtin.Exception(\"argument axisc is not supported\");\n\n\t\taxis = axis ? axis.v : 1;\n\n\t\tvar size_x = x.v.size()\n\t\tvar size_y = y.v.size()\n\n\t\tif(size_x[axis] != 3 || size_y[axis] != 3) {\n\t\t\tthrow new Sk.builtin.Exception(\"incompatible dimensions for cross product (dimension must be 3)\");\n\t\t}\n\n\t\tvar result;\n\t\ttry {\n\t\t\tif(axis == 1) {//expect row vectors\n\t\t\t\tresult=math.zeros(1,3);\n\t\t\t\tresult.subset(math.index(0,0), x.v._data[0][1]*y.v._data[0][2]-x.v._data[0][2]*y.v._data[0][1]);\n\t\t\t\tresult.subset(math.index(0,1), x.v._data[0][2]*y.v._data[0][0]-x.v._data[0][0]*y.v._data[0][2]);\n\t\t\t\tresult.subset(math.index(0,2), x.v._data[0][0]*y.v._data[0][1]-x.v._data[0][1]*y.v._data[0][0]);\n\t\t\t} else { //col vectors\n\t\t\t\tresult=math.zeros(3,1);\n\t\t\t\tresult.subset(math.index(0,0), x.v._data[1][0]*y.v._data[2][0]-x.v._data[2][0]*y.v._data[1][0]);\n\t\t\t\tresult.subset(math.index(1,0), x.v._data[2][0]*y.v._data[0][0]-x.v._data[0][0]*y.v._data[2][0]);\n\t\t\t\tresult.subset(math.index(2,0), x.v._data[0][0]*y.v._data[1][0]-x.v._data[1][0]*y.v._data[0][0]);\n\t\t\t}\n\t\t} catch(e) {\n\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t}\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\tmod.transpose = new Sk.builtin.func(function(array1) {\n\t\tSk.builtin.pyCheckArgs('transpose', arguments, 1);\n\n\t\tvar result;\n\t\ttry {\n\t\t\tresult = math.transpose(array1.v);\n\t\t} catch(e) {\n\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t}\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\tmod.concatenate = Sk.nativejs.func(function(array_tuple, axis) {\n\t\tSk.builtin.pyCheckArgs('concatenate', arguments, 1, 2);\n\t\t\n\t\taxis = axis ? axis.v : 0;\n\n\t\tvar args = [], idx, value;\n\n\t\tfor(idx = 0; idx < array_tuple.v.length; ++idx) {\n\t\t\tvalue = array_tuple.v[idx];\n\n\t\t\tif(value.tp$name === 'number') {\n\t\t\t\tvalue = math.matrix([[value.v]])\n\t\t\t} else {\n\t\t\t\tvalue = value.v;\n\t\t\t}\n\t\t\targs.push(value);\n\t\t}\n\n\t\t// dimension argument\n\t\targs.push(axis);\n\n\t\tvar result;\n\t\ttry {\n\t\t\tresult = math.concat.apply(undefined, args);\n\t\t} catch(e) {\n\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t}\n\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\tmod.hstack = new Sk.builtin.func(function(array_tuple) {\n\t\tSk.builtin.pyCheckArgs('hstack', arguments, 1, 1);\n\t\t\n\t\treturn Sk.misceval.callsim(mod.concatenate, array_tuple, Sk.builtin.nmber(1, Sk.builtin.nmber.int$));\n\t});\n\n\tmod.vstack = new Sk.builtin.func(function(array_tuple) {\n\t\tSk.builtin.pyCheckArgs('vstack', arguments, 1, 1);\n\t\t\n\t\treturn Sk.misceval.callsim(mod.concatenate, array_tuple, Sk.builtin.nmber(0, Sk.builtin.nmber.int$));\n\t});\n\n\t/**\n\t * statistic functions\n\t */\n\tmod.mean = new Sk.builtin.func(function(array1) {\n\t\tSk.builtin.pyCheckArgs('mean', arguments, 1);\n\n\t\tvar result;\n\t\ttry {\n\t\t\tresult = math.mean(array1.v);\n\t\t} catch(e) {\n\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t}\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\tmod.var_$rw$ = new Sk.builtin.func(function(array1) {\n\t\tSk.builtin.pyCheckArgs('var', arguments, 1);\n\n\t\tvar result;\n\t\ttry {\n\t\t\tresult = math['var'](array1.v);\n\t\t} catch(e) {\n\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t}\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\tmod.std = new Sk.builtin.func(function(array1) {\n\t\tSk.builtin.pyCheckArgs('std', arguments, 1);\n\n\t\tvar result;\n\t\ttry {\n\t\t\tresult = math.std(array1.v);\n\t\t} catch(e) {\n\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t}\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\t\n\tmod.cov = new Sk.builtin.func(function(array1, array2) {\n\t\tSk.builtin.pyCheckArgs('cov', arguments, 2);\n\t\t\n\t\tif(array1.v.length != array2.v.length) {\n\t\t\tthrow new Sk.builtin.Exception(\"time series must be equally long for covariance calculation\");\n\t\t}\n\n\t\tvar product, mean1, mean2, result;\n\t\ttry {\n\t\t\tproduct = math.emultiply(array1.v, array2.v);\n\t\t\tmean1 = math.mean(array1.v);\n\t\t\tmean2 = math.mean(array2.v);\n\t\t\tresult = (1/(array1.v._data.length-1))*(math.sum(product)-array1.v._data.length*mean1*mean2);\n\t\t} catch(e) {\n\t\t\tthrow new Sk.builtin.Exception(e.message);\n\t\t}\n\t\treturn Sk.misceval.callsim(mod.ndarray, undefined, result);\n\t});\n\n\t/**\n\t * logic functions\n\t */\n\tmod.allclose = new Sk.builtin.func(function(a, b) {\n\t\tSk.builtin.pyCheckArgs('allclose', arguments, 2, 4);\n\n\t\tvar rtol = 1e-5, atol = 1e-8;\n\n\t\tif(arguments.length > 2) {\n\t\t\tSk.builtin.pyCheckType('rtol', 'number', Sk.builtin.checkNumber(arguments[2]));\n\t\t\trtol = arguments[2].v\n\t\t}\n\t\tif(arguments.length > 3) {\n\t\t\tSk.builtin.pyCheckType('atol', 'number', Sk.builtin.checkNumber(arguments[3]));\n\t\t\tatol = arguments[3].v\n\t\t}\n\n\t\tvar result = true;\n\n\t\tmath.collection.deepMap2(a.v, b.v, function(v1, v2) {\n\t\t\tresult = result && (Math.abs(v1 - v2) <= (atol + rtol * Math.abs(v2)));\n\t\t});\n\n\t\treturn Sk.builtin.bool(result);\n\t});\n\n\t/**\n\t * output functions\n\t */\n\t \n\tmod.set_printoptions = new Sk.builtin.func(function(precision,suppress) {\n\t\tSk.builtin.pyCheckArgs('set_printoptions', arguments, 0);\n\t\tprecision = typeof precision !== 'undefined' ? precision : 4;\n   \t\tsuppress = typeof suppress !== 'undefined' ? suppress : true;\n   \t\tprintPrecision = precision;\n   \t\t//TODO: implement suppress small numbers\n   \t\treturn undefined;\n\t});\n\n\tmod.array_str = new Sk.builtin.func(function(array) {\n\t\tSk.builtin.pyCheckArgs('array_str', arguments, 1);\n\t\tvar str =math.format(array.v,printPrecision).replace(/\\], \\[/g, ']\\n [');\n\t\treturn Sk.builtin.str(str.replace(/,/g, ''));\n\t\t//return Sk.builtin.str(math.format(array.v));\n\t});\n\n\treturn mod;\n}\n", "src/builtin/this.py": "s = \"\"\"Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!\"\"\"\n\nd = {}\nfor c in (65, 97):\n    for i in range(26):\n        d[chr(i+c)] = chr((i+13) % 26 + c)\n\nprint \"\".join([d.get(c, c) for c in s])\n", "src/lib/simulator/controller.py": "import math\nimport numpy as np\n\n#when more order types are needed, a 'Order' superclass should be used\n\nclass RelativeOrder(object):\n    def __init__(self, dx, dy, dz, dyaw):\n        #relative movements\n        self.dx = dx\n        self.dy = dy\n        self.dz = dz\n\n        self.dyaw = (dyaw / 180.0) * math.pi\n\nclass MissionPlanner:\n    def __init__(self):\n        self.commands = []\n\n    def forward(self, distance):\n        return self._add_relative_command(distance, 0, 0, 0)\n\n    def backward(self, distance):\n        return self._add_relative_command(-distance, 0, 0, 0)\n\n    def left(self, distance):\n        return self._add_relative_command(0, distance, 0, 0)\n\n    def right(self, distance):\n        return self._add_relative_command(0, -distance, 0, 0)\n\n    def up(self, distance):\n        return self._add_relative_command(0, 0, distance, 0)\n\n    def down(self, distance):\n        return self._add_relative_command(0, 0, -distance, 0)\n\n    def turn_left(self, angle):\n        return self._add_relative_command(0, 0, 0, angle)\n\n    def turn_right(self, angle):\n        return self._add_relative_command(0, 0, 0, -angle)\n\n    def _add_relative_command(self, dx, dy, dz, dyaw):\n        self.commands.append(RelativeOrder(dx, dy, dz, dyaw))\n        return self\n\n    def add_commands(self, commands):\n        #perform typecheck of appended commands\n        for command in commands:\n            if not isinstance(command, RelativeOrder):\n                raise Exception(\"you can only add relative movement orders to the mission.\")\n        self.commands += commands\n\n\nclass PositionController:\n    command_queue     = []\n    command_queue_idx = -1\n\n    setpoint_position = np.array([[0], [0], [0]])\n    setpoint_yaw      = 0.0\n    done              = False\n\n    Kp_pos = 1.0\n    Kd_pos = 1.0\n\n    Kp_yaw = 2.0\n    Kd_yaw = 4.0\n\n    Limit_xy = 2.0\n    Limit_z  = 0.5\n\n    def __init__(self, drone, commands, do_log):\n        self.drone         = drone\n        self.command_queue = commands\n        self.do_log        = do_log\n\n    def distance_to_setpoint(self):\n        pos_diff = self.setpoint_position - self.drone.x\n        yaw_diff = 5 * (self.setpoint_yaw - self.drone.theta.item(2))\n\n        return math.sqrt(np.dot(pos_diff.transpose(), pos_diff).item(0) + yaw_diff * yaw_diff)\n\n    def update_setpoint(self, delta):\n        world_delta            = np.dot(self.drone.yaw_rotation(), np.array([[delta.dx], [delta.dy], [delta.dz]]))\n        self.setpoint_position = self.setpoint_position + world_delta\n        self.setpoint_yaw     += delta.dyaw\n\n    def clamp(self, value, limit):\n        return max(min(value, limit), -limit)\n\n    def compute_input(self):\n        if self.done:\n            return [0, 0, 0], 0;\n\n        if self.command_queue_idx < 0 or self.distance_to_setpoint() < 0.05:\n            self.command_queue_idx += 1\n\n            if self.command_queue_idx < len(self.command_queue):\n                self.update_setpoint(self.command_queue[self.command_queue_idx])\n                if self.do_log:\n                    print \"updating setpoint, position:\", self.setpoint_position.transpose(), \"yaw:\", self.setpoint_yaw\n            else:\n                self.done = True\n                if self.do_log:\n                    print \"done\"\n\n        lin_vel_cmd = self.Kp_pos * (self.setpoint_position - self.drone.x) - self.Kd_pos * self.drone.xdot;\n        yaw_vel_cmd = self.Kp_yaw * (self.setpoint_yaw - self.drone.theta.item(2)) - self.Kd_yaw * self.drone.thetadot.item(2)\n\n        return [\n            self.clamp(lin_vel_cmd.item(0), self.Limit_xy),\n            self.clamp(lin_vel_cmd.item(1), self.Limit_xy),\n            self.clamp(lin_vel_cmd.item(2), self.Limit_z)\n        ], yaw_vel_cmd\n\n\nclass Controller():\n    '''\n    Implements a PIDController\n    '''\n\n    Kp_xy = 1\n    Kd_xy = 1\n    Ki_xy = 0\n\n    Kp_roll = 3\n    Kd_roll = 9\n    Ki_roll = 0\n\n    Kp_pitch = 3\n    Kd_pitch = 9\n    Ki_pitch = 0\n\n    Kp_yaw = 1\n    Kd_yaw = 1\n    Ki_yaw = 0\n\n    Kp_z = 1\n    Kd_z = 1\n    Ki_z = 0\n\n    agressiveness_xy = 0.3\n    agressiveness_z  = 0.3\n\n    dt = 0.005\n\n    def __init__(self, drone):\n        self.drone         = drone\n        self.errorIntegral = np.array([[0], [0], [0]])\n\n        # TODO: tune gains\n        self.Kp_angular_rate = np.array([[3.0], [3.0], [1.0]])\n        self.Kp_attitude     = np.array([[5.0], [5.0], [1.0]])\n        self.Kd_attitude     = np.array([[0.0], [0.0], [0.0]])\n        self.Kp_zvelocity    = 5.0\n\n        self.Kp_lin_vel = np.array([[5.0], [5.0], [5.0]])\n        self.Kd_lin_vel = np.array([[2.5], [2.5], [0]])\n\n        self.Kp_ang_vel = 10.0\n        self.Kd_ang_vel = 5.0\n\n        self.Kp_yaw_vel = 1.0\n\n\n    def calculate_control_command3(self,dt,xdot_desired, yawdot_desired):\n\n        world_acc_cmd    = self.Kp_lin_vel * (xdot_desired - self.drone.xdot) - self.Kd_lin_vel * self.drone.xdoubledot;\n        world_acc_cmd[2] = world_acc_cmd.item(2) + self.drone.g# / (math.cos(self.drone.theta.item(1))*math.cos(self.drone.theta.item(0)))\n        #print \"world\", world_acc_cmd.transpose()\n        body_acc_cmd     = np.dot(self.drone.rotation().transpose(), world_acc_cmd)\n        body_angular_vel = self.drone.omega#np.dot(self.drone.angle_rotation_to_body(), self.drone.thetadot)\n        #print \"body\", body_angular_vel.transpose()\n\n        rates = np.array([\n            [self.Kp_ang_vel * (-body_acc_cmd.item(1) / self.drone.g) - self.Kd_ang_vel * body_angular_vel.item(0)],\n            [self.Kp_ang_vel * (body_acc_cmd.item(0) / self.drone.g) - self.Kd_ang_vel * body_angular_vel.item(1)],\n            [self.Kp_yaw_vel * (yawdot_desired - self.drone.thetadot.item(2))]\n        ]);\n\n        T_des = world_acc_cmd.item(2) / (math.cos(self.drone.theta.item(1)) * math.cos(self.drone.theta.item(0)))\n        rates = np.vstack((rates, T_des))\n        ctrl  = np.dot(self.drone.AinvKinvI, rates)\n        return ctrl, world_acc_cmd\n\n    def calculate_control_command(self,dt,theta_desired,thetadot_desired,x_desired,xdot_desired):\n        # TODO: implement z velocity controller feeding to desired thrust\n\n        T_des = self.drone.g / (math.cos(self.drone.theta.item(1))*math.cos(self.drone.theta.item(0)));\n        T_des += self.Kp_zvelocity * (xdot_desired.item(2) - self.drone.xdot.item(2))\n        #print \"T_des\",T_des\n        # attitude controller\n\n        # angular loop\n        #thetadot_desired = self.Kp_attitude * (np.dot(self.drone.yaw_rotation(), theta_desired) - self.drone.theta)# - self.Kd_attitude * self.drone.thetadot;\n        thetadot_desired = self.Kp_attitude * (theta_desired - self.drone.theta);\n        #print (theta_desired - self.drone.theta_in_body()).transpose(), thetadot_desired.transpose()\n\n        thetadot_desired[2] = theta_desired.item(2)\n\n        #print self.drone.theta.transpose(), self.drone.theta_in_body().transpose(), thetadot_desired.transpose(), self.drone.thetadot.transpose(), self.drone.thetadot_in_body().transpose();\n        #print \"err\",(theta_desired - self.drone.theta_in_body()).transpose(), theta_desired.transpose(), self.drone.theta_in_body().transpose(), self.drone.theta.transpose()\n        # angular rate controller\n        #rates = self.Kp_angular_rate * (thetadot_desired - self.drone.thetadot)\n        rates = self.Kp_angular_rate * (np.dot(self.drone.angle_rotation_to_body(), thetadot_desired) - self.drone.thetadot_in_body())\n        #print (thetadot_desired - self.drone.thetadot_in_body()).transpose(), rates.transpose()\n        #print \"theta_desired\", theta_desired\n        #print \"self.drone.theta_in_body()\", self.drone.theta_in_body()\n        #print \"thetadot_desired\",thetadot_desired\n        #print \"self.drone.thetadot\",self.drone.thetadot\n        #print \"self.drone.thetadot_in_body()\",self.drone.thetadot_in_body()\n        rates = np.vstack((rates, T_des))\n        #rates[0] = (rates[0] if rates[0] <= 1 else 1) if rates[0] >= -1 else -1;\n        #rates[1] = (rates[1] if rates[1] <= 1 else 1) if rates[1] >= -1 else -1;\n        #rates[2] = (rates[2] if rates[2] <= 1 else 1) if rates[2] >= -1 else -1;\n        #rates[3] = (rates[3] if rates[3] <= 12 else 12) if rates[2] >= 8 else 8;\n        #print \"rates1\",type(rates.item(3)),rates.item(3)\n        #print \"rates2\",rates\n        #print \"self.drone.AinvKinvI\", self.drone.AinvKinvI\n        ctrl = np.dot(self.drone.AinvKinvI, rates);\n        #print rates.transpose(), np.dot(self.drone.KA, ctrl).transpose(), ctrl.transpose();\n        #ctrl = np.min(np.hstack((ctrl, np.array([[8.0], [8.0], [8.0], [8.0]]))), 1)[:,None];\n        #print \"r\", rates.transpose(), ctrl.transpose();\n        #print \"ctrl\", ctrl\n        return ctrl\n\n    def calculate_control_command2(self, dt, theta_desired, thetadot_desired, x_desired, xdot_desired):\n        #xy control\n        e_x = x_desired.item(0) - self.drone.x.item(0) + xdot_desired.item(0) - self.drone.xdot.item(0)\n        e_y = x_desired.item(1) - self.drone.x.item(1) + xdot_desired.item(1) - self.drone.xdot.item(1)\n\n        position_cmd = self.Kp_xy*(x_desired-self.drone.x)+self.Kd_xy*(xdot_desired-self.drone.xdot)\n        u_x          = position_cmd.item(0)\n        u_y          = position_cmd.item(1)\n\n        R = np.array([[math.cos(self.drone.theta.item(2)), -math.sin(self.drone.theta.item(2))],\n                      [math.sin(self.drone.theta.item(2)),  math.cos(self.drone.theta.item(2))]])\n        u_local = np.dot(R, np.array([[u_x], [u_y]]))\n\n        #theta_desired[0] = u_local.item(0)*self.agressiveness_xy\n        #theta_desired[1] = u_local.item(1)*self.agressiveness_xy\n\n        #yaw control\n        e_yaw             = theta_desired.item(2) - self.drone.theta.item(2) #+thetadot_desired.item(2)-self.drone.thetadot.item(2)\n        u_yaw             = self.Kp_yaw * (theta_desired.item(2) - self.drone.theta.item(2)) + self.Kd_yaw * (thetadot_desired.item(2)-self.drone.thetadot.item(2))\n        #theta_desired[2] = math.atan2(math.sin(u_yaw), math.cos(u_yaw));\n        e_yaw_norm        = -u_yaw #-math.atan2(math.sin(u_yaw), math.cos(u_yaw));\n        # TODO: handle flips from +pi to -pi\n\n        #altitude control\n        e_altitude = self.Kp_z * (x_desired.item(2) - self.drone.x.item(2)) + self.Kd_z * (xdot_desired.item(2) - self.drone.xdot.item(2))\n        e_z        = x_desired.item(2)-self.drone.x.item(2)+xdot_desired.item(2)-self.drone.xdot.item(2)\n        print \"z err:\", e_altitude, x_desired.item(2), self.drone.x.item(2)\n        qtt        = (self.drone.m * self.drone.g) / (4 * self.drone.k_t * math.cos(self.drone.theta.item(1)) * math.cos(self.drone.theta.item(0)))\n        qtt        = (1 + e_altitude * self.agressiveness_z) * qtt\n\n        e_roll  = self.Kp_roll * (theta_desired.item(0) - self.drone.theta.item(0)) + self.Kd_roll * (thetadot_desired.item(0) - self.drone.thetadot.item(0))\n        e_roll  = -e_roll\n        e_pitch = self.Kp_pitch * (theta_desired.item(1) - self.drone.theta.item(1)) + self.Kd_pitch * (thetadot_desired.item(1) - self.drone.thetadot.item(1))\n        e_pitch = -e_pitch\n\n        print \"errors\", e_roll, e_pitch, e_yaw_norm\n\n        I_xx = self.drone.I.item((0, 0))\n        I_yy = self.drone.I.item((1, 1))\n        I_zz = self.drone.I.item((2, 2))\n        #print I_xx, I_yy, I_zz\n        #roll hat irgendwie keine wirkung\n\n        #gamma = angular_velocity_motor^2\n        b = self.drone.k_b\n        t = self.drone.k_t\n        L = self.drone.L\n\n        gamma1 = qtt - ((2 * b * e_roll * I_xx + e_yaw_norm * I_zz * t * L) / (4 * b * t * L))\n        gamma2 = qtt + ((e_yaw_norm * I_zz) / (4 * b)) - ((e_pitch * I_yy) / (2 * t * L))\n        gamma3 = qtt - ((-2 * b * e_roll * I_xx + e_yaw_norm * I_zz * t * L) / (4 * b * t * L))\n        gamma4 = qtt + ((e_yaw_norm * I_zz) / (4 * b)) + ((e_pitch * I_yy) / (2 * t * L))\n\n        #Make sure we don't get above 10 Ampere in total, the rating of the Ardrone 2.0 Battery\n        #@ Hovering 5.95A\n        #control_commands=[abs(gamma1),abs(gamma2),abs(gamma3),abs(gamma4)]\n        #if (sum(control_commands)>7):\n        #    print(sum(control_commands));\n        #\n        #    gamma1 = (gamma1/max(control_commands))*2.4\n        #    gamma2 = (gamma2/max(control_commands))*2.4\n        #    gamma3 = (gamma3/max(control_commands))*2.4\n        #    gamma4 = (gamma4/max(control_commands))*2.4\n        #    print(\"New controls:\")\n        #    print(gamma1,gamma2,gamma3,gamma4)\n\n        return ([gamma1, gamma2, gamma3, gamma4], e_x, e_y, e_z, e_yaw, theta_desired.item(0), theta_desired.item(1), theta_desired.item(2))\n", "src/lib/re/__init__.js": "var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // Constants (mostly unsupported)\n    mod.I = 2;\n    mod.IGNORECASE = 2;\n    // mod.L = 4;\n    // mod.LOCALE = 4;\n    mod.M = 8;\n    mod.MULTILINE = 8;\n    // mod.S = 16;\n    // mod.DOTALL = 16;\n    // mod.U = 32;\n    // mod.UNICODE = 32;\n    // mod.X = 64;\n    // mod.VERBOSE = 64;\n\n    var validGroups = [\"(?:\", \"(?=\", \"(?!\"];\n\n    var convert = function(pattern) {\n        var newpattern;\n        var match;\n        var i;\n\n        // Look for disallowed constructs\n        match = pattern.match(/\\(\\?./g);\n        if (match) {\n            for (i=0; i<match.length; i++) {\n                if (validGroups.indexOf(match[i]) == -1) {\n                    throw new Sk.builtin.ValueError(\"Disallowed group in pattern: '\"\n                                                    + match[i] + \"'\");\n                };\n            };\n        };\n\n        newpattern = pattern.replace('/\\\\/g', '\\\\\\\\');\n        newpattern = pattern.replace(/([^\\\\]){,(?![^\\[]*\\])/g, '$1{0,');\n\n        return newpattern;\n    };\n\n    var getFlags = function(flags) {\n        var jsflags = \"g\";\n        if ((flags & mod.IGNORECASE) == mod.IGNORECASE) {\n            jsflags += \"i\";\n        };\n        if ((flags & mod.MULTILINE) == mod.MULTILINE) {\n            jsflags += \"m\";\n        }; \n        return jsflags;\n    };\n\n    mod.split = Sk.nativejs.func(function split(pattern, string, maxsplit, flags) {\n        Sk.builtin.pyCheckArgs(\"split\", arguments, 2, 4);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError(\"pattern must be a string\");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError(\"string must be a string\");\n        };\n        if (maxsplit === undefined) {\n            maxsplit = 0;\n        };\n        if (!Sk.builtin.checkNumber(maxsplit)) {\n            throw new Sk.builtin.TypeError(\"maxsplit must be a number\");\n        };\n        if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError(\"flags must be a number\");\n        };\n\n\tmaxsplit = Sk.builtin.asnum$(maxsplit);\n        var pat = Sk.ffi.unwrapo(pattern);\n        var str = Sk.ffi.unwrapo(string);\n        \n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print(\"Pat: \" + pat);\n        //print(\"Str: \" + str);\n\n        var captured = !(pat.match(/^\\(.*\\)$/) === null);\n        //print(\"Captured: \", captured);\n\n        var jsflags = getFlags(flags);\n        //print(\"Flags: \", jsflags);\n\n        var regex = new RegExp(pat, jsflags);\n\n        var result = [];\n        var match;\n        var index = 0;\n        var splits = 0;\n        while ((match = regex.exec(str)) != null) {\n            //print(\"Matched '\" + match[0] + \"' at position \" + match.index + \n            //      \"; next search at \" + regex.lastIndex);\n            if (match.index === regex.lastIndex) {\n                // empty match\n                break;\n            };\n            result.push(new Sk.builtin.str(str.substring(index, match.index)));\n            if (captured) {\n                // Add matching pattern, too\n                result.push(new Sk.builtin.str(match[0]));\n            };\n            index = regex.lastIndex;\n            splits += 1;\n            if (maxsplit && (splits >= maxsplit)) {\n                break;\n            };\n        };\n        result.push(new Sk.builtin.str(str.substring(index)));\n\n        return new Sk.builtin.list(result);\n    });\n\n    mod.findall = Sk.nativejs.func(function findall(pattern, string, flags) {\n        Sk.builtin.pyCheckArgs(\"findall\", arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError(\"pattern must be a string\");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError(\"string must be a string\");\n        };\n        if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError(\"flags must be a number\");\n        };\n\n        var pat = Sk.ffi.unwrapo(pattern);\n        var str = Sk.ffi.unwrapo(string);\n        \n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print(\"Pat: \" + pat);\n        //print(\"Str: \" + str);\n\n        var jsflags = getFlags(flags);\n        //print(\"Flags: \", jsflags);\n\n        var regex = new RegExp(pat, jsflags);\n\n        if (pat.match(/\\$/)) {\n\t    var newline_at_end = new RegExp(/\\n$/);\n\t    if (str.match(newline_at_end)) {\n\t        str = str.slice(0,-1);\n\t    }\n        }\n\n        var result = [];\n        var match;\n        while ((match = regex.exec(str)) != null) {\n            //print(\"Matched '\" + match[0] + \"' at position \" + match.index + \n            //      \"; next search at \" + regex.lastIndex);\n            // print(\"match: \" + JSON.stringify(match));\n            if (match.length < 2) {\n                result.push(new Sk.builtin.str(match[0]));\n            } else if (match.length == 2) {\n                result.push(new Sk.builtin.str(match[1]));\n            } else {\n                var groups = [];\n                for (var i=1; i<match.length; i++) {\n                    groups.push(new Sk.builtin.str(match[i]));  \n                };\n                result.push(new Sk.builtin.tuple(groups));\n            };\n            if (match.index === regex.lastIndex) {\n                regex.lastIndex += 1;\n            };\n        };\n\n        return new Sk.builtin.list(result);\n    });\n\n\n    var matchobj = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,thematch, pattern, string) {\n            self.thematch = thematch;\n\t    self.re = pattern;\n\t    self.string = string;\n        });\n\n\t$loc.groups = new Sk.builtin.func(function(self) {\n\t    return new Sk.builtin.tuple(self.thematch.v.slice(1))\n\t});\n\n\t$loc.group = new Sk.builtin.func(function(self,grpnum) {\n\t    if (grpnum === undefined) {\n                grpnum = 0;\n            }\n            else {\n                grpnum = Sk.builtin.asnum$(grpnum);\n            }\n\t    if(grpnum >= self.thematch.v.length) {\n\t\tthrow new Sk.builtin.IndexError(\"Index out of range: \" + grpnum);\n\t\t}\n\t    return self.thematch.v[grpnum]\n\t});\n\n    }\n\n    mod.MatchObject = Sk.misceval.buildClass(mod, matchobj, 'MatchObject', []);\n\n    // Internal function to return a Python list of strings \n    // From a JS regular expression string\n    mod._findre = function(res, string) {\n\tres = res.replace(/([^\\\\]){,(?![^\\[]*\\])/g, '$1{0,');\n        var re = eval(res);\n\tvar patt = new RegExp('\\n$');\n\tif (string.v.match(patt))\n\t    var matches = string.v.slice(0,-1).match(re);\n\telse\n            var matches = string.v.match(re);\n        retval = new Sk.builtin.list();\n        if ( matches == null ) return retval;\n        for (var i = 0; i < matches.length; ++i) {\n            var sitem = new Sk.builtin.str(matches[i]);\n            retval.v.push(sitem);\n        }\n        return retval;\n    }\n\n    mod.search = new Sk.builtin.func(function(pattern, string, flags) {\n\tSk.builtin.pyCheckArgs('search', arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError(\"pattern must be a string\");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError(\"string must be a string\");\n        };\n\tif (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError(\"flags must be a number\");\n        };\n        var res = \"/\"+pattern.v.replace(/\\//g,\"\\\\/\")+\"/\";\n        lst = mod._findre(res,string);\n        if ( lst.v.length < 1 ) return Sk.builtin.none.none$;\n        var mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    });\n\n    mod.match = new Sk.builtin.func(function(pattern, string, flags) {\n\tSk.builtin.pyCheckArgs('match', arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError(\"pattern must be a string\");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError(\"string must be a string\");\n        };\n\tif (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError(\"flags must be a number\");\n        };\n        var res = \"/^\"+pattern.v.replace(/\\//g,\"\\\\/\")+\"/\";\n        lst = mod._findre(res,string);\n        if ( lst.v.length < 1 ) return Sk.builtin.none.none$;\n        var mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    });\n\n    return mod;\n}\n", "src/lib/simulator/navdata.py": "class Navdata(object):\n    '''\n    drone navdata storage.\n\n    this represents the current state of the drone.\n    '''\n\n    def __init__(self):\n        # 0 means no battery, 100 means full battery\n        self.battery = 50\n\n        # 0: Unknown, 1: Init, 2: Landed, 3: Flying, 4: Hovering, 5: Test\n        # 6: Taking off, 7: Goto Fix Point, 8: Landing, 9: Looping\n        # Note: 3,7 seems to discriminate type of flying (isFly = 3 | 7)\n        self.state = 0\n\n        # magnetometer\n\n        self.magX = 0\n        self.magY = 0\n        self.magZ = 0\n\n        # pressure sensor\n        self.pressure = 0\n\n        # apparently, there was a temperature sensor added as well.\n        self.temp = 0\n\n        # wind sensing...\n        self.wind_speed      = 0\n        self.wind_angle      = 0\n        self.wind_comp_angle = 0\n\n        # left/right tilt in degrees (rotation about the X axis)\n        self.rotX = 0\n\n        # forward/backward tilt in degrees (rotation about the Y axis)\n        self.rotY = 0\n\n        # orientation in degrees (rotation about the Z axis)\n        self.rotZ = 0\n\n        # estimated altitude (cm)\n        self.altd = 0\n\n        # linear velocity (mm/sec)\n        self.vx = 0\n\n        # linear velocity (mm/sec)\n        self.vy = 0\n\n        # linear velocity (mm/sec)\n        self.vz = 0\n\n        #linear accelerations (unit: g)\n        self.ax = 0\n        self.ay = 0\n        self.az = 0\n\n        #motor commands (unit 0 to 255)\n        self.motor1 = 0\n        self.motor2 = 0\n        self.motor3 = 0\n        self.motor4 = 0\n\n        #Tags in Vision Detectoion\n        self.tags_count       = 0\n        self.tags_type        = []\n        self.tags_xc          = []\n        self.tags_yc          = []\n        self.tags_width       = []\n        self.tags_height      = []\n        self.tags_orientation = []\n        self.tags_distance    = []\n\n        #time stamp\n        self.tm = 0\n", "src/lib/unittest/gui.py": "import document\nfrom unittest import TestCase\n\nclass TestCaseGui(TestCase):\n\tdef __init__(self):\n\t\tTestCase.__init__(self)\n\n\t\tself.divid = document.currentDiv()\n\t\tself.mydiv = document.getElementById(self.divid)\n\t\tres = document.getElementById(self.divid+'_unit_results')\n\t\tif res:\n\t\t\tself.resdiv = res\n\t\t\tres.innerHTML = ''\n\t\telse:\n\t\t\tself.resdiv = document.createElement('div')\n\t\t\tself.resdiv.setAttribute('id',self.divid+'_unit_results')\n\t\t\tself.resdiv.setAttribute('class','unittest-results')\n\t\tself.mydiv.appendChild(self.resdiv)\n\n\n\tdef main(self):\n\t\tl = document.createElement('ul')\n\t\tself.resdiv.appendChild(l)\n\t\tself.resList = l\n\n\t\tfor func in self.tlist:\n\t\t\ttry:\n\t\t\t\tself.setup()\n\t\t\t\tfunc()\n\t\t\t\tself.tearDown()\n\t\t\texcept:\n\t\t\t\tself.appendResult('Error')\n\t\t\t\tself.numFailed += 1\n\t\tself.showSummary()\n\n\tdef appendResult(self,res,actual,expected,feedback):\n\t\tif res == 'Error':\n\t\t\tmsg = 'Error'\n\t\telif res:\n\t\t\tmsg = 'Pass'\n\t\t\tself.numPassed += 1\n\t\telse:\n\t\t\tmsg = 'Fail: expected %s  %s ' % (str(actual),str(expected)) + feedback\n\t\t\tself.numFailed += 1\n\n\t\tpTag = document.createElement('li')\n\t\tpTag.innerHTML = msg\n\t\tself.resList.appendChild(pTag)\n\n\n\n\tdef showSummary(self):\n\t\tpct = self.numPassed / (self.numPassed+self.numFailed) * 100\n\t\tpTag = document.createElement('p')\n\t\tpTag.innerHTML = \"You passed: \" + str(pct) + \"% of the tests\"\n\t\tself.resdiv.appendChild(pTag)\n\t\tif pct < 90:\n\t\t\tself.resdiv.setCSS('background-color','#de8e96')\n\t\telse:\n\t\t\tself.resdiv.setCSS('background-color','#83d382')\n", "src/lib/quadrotor/__init__.py": "", "src/lib/random/__init__.js": "\n/*\n  I've wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace\n  so it's better encapsulated. Now you can have multiple random number generators\n  and they won't stomp all over eachother's state.\n  \n  If you want to use this as a substitute for Math.random(), use the random()\n  method like so:\n  \n  var m = new MersenneTwister();\n  var randomNumber = m.random();\n  \n  You can also call the other genrand_{foo}() methods on the instance.\n\n  If you want to use a specific seed in order to get a repeatable random\n  sequence, pass an integer into the constructor:\n\n  var m = new MersenneTwister(123);\n\n  and that will always produce the same random sequence.\n\n  Sean McCullough (banksean@gmail.com)\n*/\n\n/* \n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n \n   Before using, initialize the state by using init_genrand(seed)  \n   or init_by_array(init_key, key_length).\n \n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.                          \n \n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n \n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n \n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n \n     3. The names of its contributors may not be used to endorse or promote \n        products derived from this software without specific prior written \n        permission.\n \n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n \n \n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nvar MersenneTwister = function(seed) {\n  if (seed == undefined) {\n    seed = new Date().getTime();\n  } \n  /* Period parameters */  \n  this.N = 624;\n  this.M = 397;\n  this.MATRIX_A = 0x9908b0df;   /* constant vector a */\n  this.UPPER_MASK = 0x80000000; /* most significant w-r bits */\n  this.LOWER_MASK = 0x7fffffff; /* least significant r bits */\n \n  this.mt = new Array(this.N); /* the array for the state vector */\n  this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */\n\n  this.init_genrand(seed);\n}  \n \n/* initializes mt[N] with a seed */\nMersenneTwister.prototype.init_genrand = function(s) {\n  this.mt[0] = s >>> 0;\n  for (this.mti=1; this.mti<this.N; this.mti++) {\n      var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);\n   this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)\n  + this.mti;\n      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n      /* In the previous versions, MSBs of the seed affect   */\n      /* only MSBs of the array mt[].                        */\n      /* 2002/01/09 modified by Makoto Matsumoto             */\n      this.mt[this.mti] >>>= 0;\n      /* for >32 bit machines */\n  }\n}\n \n/* initialize by an array with array-length */\n/* init_key is the array for initializing keys */\n/* key_length is its length */\n/* slight change for C++, 2004/2/26 */\nMersenneTwister.prototype.init_by_array = function(init_key, key_length) {\n  var i, j, k;\n  this.init_genrand(19650218);\n  i=1; j=0;\n  k = (this.N>key_length ? this.N : key_length);\n  for (; k; k--) {\n    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)\n    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))\n      + init_key[j] + j; /* non linear */\n    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n    i++; j++;\n    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n    if (j>=key_length) j=0;\n  }\n  for (k=this.N-1; k; k--) {\n    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);\n    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))\n      - i; /* non linear */\n    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n    i++;\n    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n  }\n\n  this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */ \n}\n \n/* generates a random number on [0,0xffffffff]-interval */\nMersenneTwister.prototype.genrand_int32 = function() {\n  var y;\n  var mag01 = new Array(0x0, this.MATRIX_A);\n  /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n  if (this.mti >= this.N) { /* generate N words at one time */\n    var kk;\n\n    if (this.mti == this.N+1)   /* if init_genrand() has not been called, */\n      this.init_genrand(5489); /* a default initial seed is used */\n\n    for (kk=0;kk<this.N-this.M;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    for (;kk<this.N-1;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);\n    this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];\n\n    this.mti = 0;\n  }\n\n  y = this.mt[this.mti++];\n\n  /* Tempering */\n  y ^= (y >>> 11);\n  y ^= (y << 7) & 0x9d2c5680;\n  y ^= (y << 15) & 0xefc60000;\n  y ^= (y >>> 18);\n\n  return y >>> 0;\n}\n \n/* generates a random number on [0,0x7fffffff]-interval */\nMersenneTwister.prototype.genrand_int31 = function() {\n  return (this.genrand_int32()>>>1);\n}\n \n/* generates a random number on [0,1]-real-interval */\nMersenneTwister.prototype.genrand_real1 = function() {\n  return this.genrand_int32()*(1.0/4294967295.0); \n  /* divided by 2^32-1 */ \n}\n\n/* generates a random number on [0,1)-real-interval */\nMersenneTwister.prototype.random = function() {\n  return this.genrand_int32()*(1.0/4294967296.0); \n  /* divided by 2^32 */\n}\n \n/* generates a random number on (0,1)-real-interval */\nMersenneTwister.prototype.genrand_real3 = function() {\n  return (this.genrand_int32() + 0.5)*(1.0/4294967296.0); \n  /* divided by 2^32 */\n}\n \n/* generates a random number on [0,1) with 53-bit resolution*/\nMersenneTwister.prototype.genrand_res53 = function() { \n  var a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6; \n  return(a*67108864.0+b)*(1.0/9007199254740992.0); \n} \n\n/* These real versions are due to Isaku Wada, 2002/01/09 added */\n\n\n\nvar $builtinmodule = function(name)\n{\n\n    var mod = {};\n\n    var myGenerator = new MersenneTwister();\n\n    mod.seed = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"seed\", arguments, 0, 1);\n\tx = Sk.builtin.asnum$(x);\n\n        if (arguments.length > 0)\n            myGenerator = new MersenneTwister(x);\n        else\n            myGenerator = new MersenneTwister();\n\n\treturn Sk.builtin.none.none$;\n    });\n\n    mod.random = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs(\"random\", arguments, 0, 0);\n\n\treturn new Sk.builtin.nmber(myGenerator.genrand_res53(), Sk.builtin.nmber.float$);\n    });\n\n    var toInt = function(num) {\n        return num | 0;\n    };\n\n    var randrange = function(start, stop, step) {\n        // Ported from CPython 2.7\n        var width, n, ret;\n\n        if (!Sk.builtin.checkInt(start)) {\n            throw new Sk.builtin.ValueError(\"non-integer first argument for randrange()\");\n        };\n\n        if (stop === undefined) {\n            // Random in [0, start)\n            ret = toInt(myGenerator.genrand_res53() * start);\n\t    return new Sk.builtin.nmber(ret, Sk.builtin.nmber.int$);\n        };\n\n        if (!Sk.builtin.checkInt(stop)) {\n            throw new Sk.builtin.ValueError(\"non-integer stop for randrange()\");\n        };\n\n        if (step === undefined) {\n            step = 1;\n        };\n\n        width = stop - start;\n\n        if ((step == 1) && (width > 0)) {\n            // Random in [start, stop), must use toInt on product for correct results with negative ranges\n            ret = start + toInt(myGenerator.genrand_res53() * width);\n\t    return new Sk.builtin.nmber(ret, Sk.builtin.nmber.int$);\n        };\n\n        if (step == 1) {\n            throw new Sk.builtin.ValueError(\"empty range for randrange() (\" + start + \", \" + stop + \", \" + width + \")\");\n        };\n\n        if (!Sk.builtin.checkInt(step)) {\n            throw new Sk.builtin.ValueError(\"non-integer step for randrange()\");\n        };\n\n        if (step > 0) {\n            n = toInt((width + step - 1) / step);\n        } else if (step < 0) {\n            n = toInt((width + step + 1) / step);\n        } else {\n            throw new Sk.builtin.ValueError(\"zero step for randrange()\");\n        };\n\n        if (n <= 0) {\n            throw new Sk.builtin.ValueError(\"empty range for randrange()\");\n        };\n\n        // Random in range(start, stop, step)\n        ret = start + (step * toInt(myGenerator.genrand_res53() * n));\n\treturn new Sk.builtin.nmber(ret, Sk.builtin.nmber.int$);\n    };\n\n    mod.randint = new Sk.builtin.func(function(a, b) {\n        Sk.builtin.pyCheckArgs(\"randint\", arguments, 2, 2);\n\n\ta = Sk.builtin.asnum$(a);\n\tb = Sk.builtin.asnum$(b);\n        return randrange(a, b+1);\n    });\n\n    mod.randrange = new Sk.builtin.func(function(start, stop, step) {\n        Sk.builtin.pyCheckArgs(\"randrange\", arguments, 1, 3);\n\n\tstart = Sk.builtin.asnum$(start);\n\tstop = Sk.builtin.asnum$(stop);\n\tstep = Sk.builtin.asnum$(step);\n        return randrange(start, stop, step);\n    });\n\n    mod.choice = new Sk.builtin.func(function(seq) {\n        Sk.builtin.pyCheckArgs(\"choice\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"seq\", \"sequence\", Sk.builtin.checkSequence(seq));\n\n        if (seq.sq$length !== undefined) {\n            var r = toInt(myGenerator.genrand_res53() * seq.sq$length());\n            return seq.mp$subscript(r);\n        } else {\n            throw new Sk.builtin.TypeError(\"object has no length\");\n        }\n    });\n\n    mod.shuffle = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"shuffle\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"sequence\", Sk.builtin.checkSequence(x));\n\n        if (x.sq$length !== undefined) {\n            if (x.mp$ass_subscript !== undefined) {\n                for (var i = x.sq$length() - 1; i > 0; i -= 1) {\n                    var r = toInt(myGenerator.genrand_res53() * (i + 1));\n                    var tmp = x.mp$subscript(r);\n                    x.mp$ass_subscript(r, x.mp$subscript(i));\n                    x.mp$ass_subscript(i, tmp);\n                };\n            } else {\n                throw new Sk.builtin.TypeError(\"object is immutable\");\n            };\n        } else {\n            throw new Sk.builtin.TypeError(\"object has no length\");\n        };        \n\n\treturn Sk.builtin.none.none$;\n    });\n\n    return mod;\n}\n", "src/lib/math/__init__.js": "var $builtinmodule = function(name)\n{\n    var mod = {};\n    mod.pi = Sk.builtin.assk$(Math.PI, Sk.builtin.nmber.float$);\n    mod.e =  Sk.builtin.assk$(Math.E, Sk.builtin.nmber.float$);\n\n//\tRNL\tadded\n    mod.fabs = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"fabs\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\treturn new Sk.builtin.nmber(Math.abs(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.asin = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs(\"asin\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n\treturn new Sk.builtin.nmber(Math.asin(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.acos = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs(\"acos\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n\treturn new Sk.builtin.nmber(Math.acos(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.atan = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs(\"atan\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n\treturn new Sk.builtin.nmber(Math.atan(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.atan2 = new Sk.builtin.func(function(y, x) {\n        Sk.builtin.pyCheckArgs(\"atan2\", arguments, 2, 2);\n        Sk.builtin.pyCheckType(\"y\", \"number\", Sk.builtin.checkNumber(y));\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\treturn new Sk.builtin.nmber(Math.atan2(Sk.builtin.asnum$(y), Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.sin = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs(\"sin\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n\treturn new Sk.builtin.nmber(Math.sin(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.cos = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs(\"cos\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n\treturn new Sk.builtin.nmber(Math.cos(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.tan = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs(\"tan\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n\treturn new Sk.builtin.nmber(Math.tan(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.asinh = new Sk.builtin.func(function(x) {\n\tSk.builtin.pyCheckArgs(\"asinh\", arguments, 1, 1);\n\tSk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\tx = Sk.builtin.asnum$(x);\n\n\tvar L = x + Math.sqrt(x*x+1);\n\n\treturn new Sk.builtin.nmber(Math.log(L), Sk.builtin.nmber.float$);\n    });\n\n    mod.acosh = new Sk.builtin.func(function(x) {\n\tSk.builtin.pyCheckArgs(\"acosh\", arguments, 1, 1);\n\tSk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\tx = Sk.builtin.asnum$(x);\n\n\tvar L = x + Math.sqrt(x*x-1);\n\n\treturn new Sk.builtin.nmber(Math.log(L), Sk.builtin.nmber.float$);\n    });\n\n    mod.atanh = new Sk.builtin.func(function(x) {\n\tSk.builtin.pyCheckArgs(\"atanh\", arguments, 1, 1);\n\tSk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\tx = Sk.builtin.asnum$(x);\n\n\tvar L = (1+x)/(1-x);\n\n\treturn new Sk.builtin.nmber(Math.log(L)/2, Sk.builtin.nmber.float$);\n    });\n\n    mod.sinh = new Sk.builtin.func(function(x) {\n\tSk.builtin.pyCheckArgs(\"sinh\", arguments, 1, 1);\n\tSk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\tx = Sk.builtin.asnum$(x);\n\n\tvar e = Math.E;\n\tvar p = Math.pow(e, x);\n\tvar n = 1/p;\n\tvar result = (p-n)/2;\n\n\treturn new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);\n    });\n\n    mod.cosh = new Sk.builtin.func(function(x) {\n\tSk.builtin.pyCheckArgs(\"cosh\", arguments, 1, 1);\n\tSk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\tx = Sk.builtin.asnum$(x);\n\n\tvar e = Math.E;\n\tvar p = Math.pow(e, x);\n\tvar n = 1/p;\n\tvar result = (p+n)/2;\n\n\treturn new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);\n    });\n\n    mod.tanh = new Sk.builtin.func(function(x) {\n\tSk.builtin.pyCheckArgs(\"tanh\", arguments, 1, 1);\n\tSk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\tx = Sk.builtin.asnum$(x);\n\n\tvar e = Math.E;\n\tvar p = Math.pow(e, x);\n\tvar n = 1/p;\n\tvar result = ((p-n)/2)/((p+n)/2);\n\n\treturn new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);\n    });\n\n    mod.ceil = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"ceil\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\treturn new Sk.builtin.nmber(Math.ceil(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.floor = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"floor\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\treturn new Sk.builtin.nmber(Math.floor(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.sqrt = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"sqrt\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\treturn new Sk.builtin.nmber(Math.sqrt(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.trunc = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"trunc\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        return new Sk.builtin.nmber(Sk.builtin.asnum$(x)|0, Sk.builtin.nmber.int$);\n    });\n\n    mod.log = new Sk.builtin.func(function(x, base) {\n        Sk.builtin.pyCheckArgs(\"log\", arguments, 1, 2);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        if (base === undefined) {\n\t    return new Sk.builtin.nmber(Math.log(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n        } else {\n            Sk.builtin.pyCheckType(\"base\", \"number\", Sk.builtin.checkNumber(base));\n            var ret = Math.log(Sk.builtin.asnum$(x)) / Math.log(Sk.builtin.asnum$(base));\n\t    return new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);\n        }\n    });\n\n    mod.log10 = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"log10\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        var ret = Math.log(Sk.builtin.asnum$(x)) / Math.log(10);\n\treturn new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);\n    });\n\n    mod.exp = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"exp\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\treturn new Sk.builtin.nmber(Math.exp(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.pow = new Sk.builtin.func(function(x,y) {\n        Sk.builtin.pyCheckArgs(\"pow\", arguments, 2, 2);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n        Sk.builtin.pyCheckType(\"y\", \"number\", Sk.builtin.checkNumber(y));\n\n\treturn new Sk.builtin.nmber(Math.pow(Sk.builtin.asnum$(x), Sk.builtin.asnum$(y)), Sk.builtin.nmber.float$);\n    });\n\n    mod.radians = new Sk.builtin.func(function(deg) {\n        Sk.builtin.pyCheckArgs(\"radians\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"deg\", \"number\", Sk.builtin.checkNumber(deg));\n\n\tvar ret = Math.PI / 180.0 * Sk.builtin.asnum$(deg);\n\treturn new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);\n    });\n\n    mod.degrees = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs(\"degrees\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n\tvar ret = 180.0 / Math.PI * Sk.builtin.asnum$(rad);\n\treturn new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);\n    });\n\n    mod.hypot = new Sk.builtin.func(function(x, y) {\n\tSk.builtin.pyCheckArgs(\"hypot\", arguments, 2, 2);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\tSk.builtin.pyCheckType(\"y\", \"number\", Sk.builtin.checkNumber(y));\n\n\t\tx = Sk.builtin.asnum$(x);\n\t\ty = Sk.builtin.asnum$(y);\n\treturn new Sk.builtin.nmber(Math.sqrt((x*x)+(y*y)), Sk.builtin.nmber.float$);\n    });\n\n\tmod.factorial = new Sk.builtin.func(function(x) {\n\t    Sk.builtin.pyCheckArgs(\"factorial\", arguments, 1, 1);\n            Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\t\tx = Math.floor(Sk.builtin.asnum$(x));\n\t\tvar r = 1;\n\t\tfor (var i = 2; i <= x; i++)\n\t\t\tr *= i;\n\t\treturn new Sk.builtin.nmber(r, Sk.builtin.nmber.int$);\n\t});\n\n    return mod;\n}"}}